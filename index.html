<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Multiplayer Backrooms Game</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        
        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 999;
            color: #e9e566;
            font-family: monospace;
            transition: opacity 1s;
        }
        
        #loading-bar-container {
            width: 50%;
            height: 30px;
            background-color: #222;
            border: 2px solid #e9e566;
            margin-top: 20px;
            position: relative;
        }
        
        #loading-bar {
            height: 100%;
            width:0%;
            background-color: #e9e566;
            transition: width 0.3s;
        }
        
        #loading-text {
            font-size: 24px;
            margin-bottom: 10px;
        }
        
        #loading-progress {
            position: absolute;
            width: 100%;
            text-align: center;
            top: 5px;
            font-size: 16px;
        }
        
        #start-button {
            margin-top: 30px;
            padding: 10px 20px;
            background-color: #e9e566;
            color: #000;
            border: none;
            font-family: monospace;
            font-size: 18px;
            cursor: pointer;
            display: none;
        }
        
        #start-button:hover {
            background-color: #fff;
        }
        
        #game-ui {
            position: fixed;
            bottom: 20px;
            left: 20px;
            color: #e9e566;
            font-family: monospace;
            font-size: 14px;
            z-index: 10;
            text-shadow: 1px 1px 2px #000;
        }
        
        #fps-counter {
            position: fixed;
            top: 10px;
            right: 10px;
            color: #e9e566;
            font-family: monospace;
            font-size: 14px;
            z-index: 10;
            text-shadow: 1px 1px 2px #000;
            background-color: rgba(0, 0, 0, 0.3);
            padding: 5px 10px;
            border-radius: 3px;
        }
        
        #audio-controls {
            position: fixed;
            bottom: 50px;
            left: 20px;
            color: #e9e566;
            font-family: monospace;
            font-size: 14px;
            z-index: 10;
            text-shadow: 1px 1px 2px #000;
            display: none;
        }
        
        #volume-slider {
            width: 100px;
            margin-left: 10px;
            vertical-align: middle;
        }
        
        /* Multiplayer UI */
        #multiplayer-ui {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #e9e566;
            font-family: monospace;
            font-size: 14px;
            z-index: 10;
            text-shadow: 1px 1px 2px #000;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            display: none;
        }
        
        #peer-id {
            font-weight: bold;
            margin-bottom: 10px;
        }
        
        #connect-form {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        #connect-form input {
            padding: 5px;
            background-color: #333;
            border: 1px solid #e9e566;
            color: #e9e566;
            font-family: monospace;
        }
        
        #connect-form button {
            padding: 5px 10px;
            background-color: #e9e566;
            color: #000;
            border: none;
            font-family: monospace;
            cursor: pointer;
            margin-top: 5px;
        }
        
        #connect-form button:hover {
            background-color: #fff;
        }
        
        #connection-status {
            margin-top: 10px;
            font-style: italic;
        }
        
        /* Chat UI */
        #chat-container {
            position: fixed;
            bottom: 100px;
            left: 20px;
            width: 300px;
            color: #e9e566;
            font-family: monospace;
            font-size: 14px;
            z-index: 10;
            text-shadow: 1px 1px 2px #000;
            display: none;
        }
        
        #chat-messages {
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px 5px 0 0;
            max-height: 150px;
            overflow-y: auto;
            margin-bottom: 5px;
        }
        
        #chat-form {
            display: flex;
            gap: 5px;
        }
        
        #chat-input {
            flex-grow: 1;
            padding: 5px;
            background-color: rgba(0, 0, 0, 0.5);
            border: 1px solid #e9e566;
            color: #e9e566;
            font-family: monospace;
            border-radius: 0 0 0 5px;
        }
        
        #chat-send {
            padding: 5px 10px;
            background-color: #e9e566;
            color: #000;
            border: none;
            font-family: monospace;
            cursor: pointer;
            border-radius: 0 0 5px 0;
        }
        
        #chat-send:hover {
            background-color: #fff;
        }
        
        .chat-message {
            margin-bottom: 5px;
            word-wrap: break-word;
        }
        
        .chat-message.self {
            color: #a8e566;
        }
        
        .chat-message.other {
            color: #e5c066;
        }
        
        .chat-message.system {
            color: #e566a8;
            font-style: italic;
        }
        
        #voice-chat-controls {
            position: fixed;
            top: 40px;
            right: 10px;
            color: #e9e566;
            font-family: monospace;
            font-size: 14px;
            z-index: 10;
            text-shadow: 1px 1px 2px #000;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            display: none;
            text-align: right;
        }
        
        #voice-chat-status {
            margin-bottom: 10px;
        }
        
        #voice-chat-controls button {
            padding: 5px 10px;
            background-color: #e9e566;
            color: #000;
            border: none;
            font-family: monospace;
            cursor: pointer;
            margin-left: 5px;
        }
        
        #voice-chat-controls button:hover {
            background-color: #fff;
        }
        
        #voice-chat-controls button.active {
            background-color: #a8e566;
        }
        
        #voice-chat-controls button.muted {
            background-color: #e56666;
        }
        
        #voice-chat-toggle.active, #voice-chat-mute.active {
            background-color: #fff;
        }
        
        /* Mobile Controls */
        #mobile-controls {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 5;
            pointer-events: none;
            display: none;
        }
        
        #joystick-container {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 120px;
            height: 120px;
            background-color: rgba(0, 0, 0, 0.3);
            border: 2px solid #e9e566;
            border-radius: 50%;
            pointer-events: auto;
            touch-action: none;
        }
        
        #joystick {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 50px;
            height: 50px;
            background-color: #e9e566;
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }
        
        #mobile-action-buttons {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            pointer-events: auto;
        }
        
        .mobile-button {
            width: 60px;
            height: 60px;
            background-color: rgba(0, 0, 0, 0.5);
            border: 2px solid #e9e566;
            border-radius: 50%;
            color: #e9e566;
            font-family: monospace;
            font-weight: bold;
            font-size: 16px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            user-select: none;
        }
        
        .mobile-button.active {
            background-color: #e9e566;
            color: #000;
        }
        
        #mobile-controls-toggle {
            position: fixed;
            top: 10px;
            left: 10px;
            padding: 5px 10px;
            background-color: rgba(0, 0, 0, 0.5);
            border: 1px solid #e9e566;
            color: #e9e566;
            font-family: monospace;
            font-size: 12px;
            z-index: 20;
            cursor: pointer;
            display: none;
        }
        
        /* Responsive adjustments for mobile */
        @media (max-width: 768px) {
            #loading-bar-container {
                width: 80%;
            }
            
            #game-ui {
                font-size: 12px;
                max-width: 80%;
            }
            
            #chat-container {
                width: 80%;
                max-width: 300px;
            }
            
            #multiplayer-ui {
                max-width: 80%;
            }
            
            #voice-chat-controls {
                bottom: 80px;
            }
            
            #desktop-controls {
                display: none;
            }
            
            #mobile-controls-info {
                display: block;
            }
        }
        
        /* Hide mobile controls info by default (for desktop) */
        #mobile-controls-info {
            display: none;
        }
    </style>
</head>
<body>
    <div id="loading-screen">
        <div id="loading-text">FALLING INTO THE BACKROOMS</div>
        <div id="loading-bar-container">
            <div id="loading-bar"></div>
            <div id="loading-progress">0%</div>
        </div>
        <button id="start-button">ENTER</button>
    </div>
    
    <div id="game-ui" style="display: none;">
        <div id="desktop-controls">WASD: Move | SHIFT: Run | CTRL: Crouch | F: Backflip | CLICK: Look | T: Chat | V: Toggle Direction Helper | B: Toggle Voice Chat</div>
        <div id="mobile-controls-info">Use the joystick to move, swipe to look around, and the buttons for actions</div>
    </div>
    
    <div id="fps-counter" style="display: none;">FPS: 0</div>
    
    <div id="audio-controls" style="display: none;">
        <span>Sound: </span>
        <input type="range" id="volume-slider" min="0" max="100" value="70">
        <span id="volume-value">70%</span>
    </div>
    
    <!-- Multiplayer UI -->
    <div id="multiplayer-ui">
        <div id="peer-id">Your ID: <span id="my-peer-id">Connecting...</span></div>
        <div id="connect-form">
            <input type="text" id="remote-peer-id" placeholder="Enter peer ID to connect">
            <button id="connect-button">Connect</button>
        </div>
        <div id="connection-status">Not connected</div>
    </div>
    
    <!-- Chat UI -->
    <div id="chat-container" style="display: none;">
        <div id="chat-messages"></div>
        <form id="chat-form">
            <input type="text" id="chat-input" placeholder="Type a message..." autocomplete="off">
            <button type="submit" id="chat-send">Send</button>
        </form>
    </div>
    
    <!-- Voice Chat Controls -->
    <div id="voice-chat-controls">
        <div id="voice-chat-status">Voice Chat: Disconnected</div>
        <button id="voice-chat-toggle">Enable Voice</button>
        <button id="voice-chat-mute">Mute Mic</button>
    </div>
    
    <!-- Mobile Controls -->
    <div id="mobile-controls">
        <div id="joystick-container">
            <div id="joystick"></div>
        </div>
        <div id="mobile-action-buttons">
            <div id="run-button" class="mobile-button">RUN</div>
            <div id="crouch-button" class="mobile-button">DUCK</div>
            <div id="action-button" class="mobile-button">ACT</div>
        </div>
    </div>
    
    <button id="mobile-controls-toggle">Toggle Controls</button>
    
    <audio id="fluorescent-buzz" loop preload="auto">
        <source src="fluorescent.mp3" type="audio/mpeg">
    </audio>
    
    <!-- PeerJS Library -->
    <script src="https://unpkg.com/peerjs@1.5.4/dist/peerjs.min.js"></script>
    
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.174.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.174.0/examples/jsm/"
        }
    }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
        import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';

        const loadingScreen = document.getElementById('loading-screen');
        const loadingBar = document.getElementById('loading-bar');
        const loadingProgressElement = document.getElementById('loading-progress');
        const startButton = document.getElementById('start-button');
        const fpsCounter = document.getElementById('fps-counter');
        const multiplayerUI = document.getElementById('multiplayer-ui');
        const myPeerIdElement = document.getElementById('my-peer-id');
        const remotePeerIdInput = document.getElementById('remote-peer-id');
        const connectButton = document.getElementById('connect-button');
        const connectionStatus = document.getElementById('connection-status');
        const chatContainer = document.getElementById('chat-container');
        const chatMessages = document.getElementById('chat-messages');
        const chatForm = document.getElementById('chat-form');
        const chatInput = document.getElementById('chat-input');
        const volumeSlider = document.getElementById('volume-slider');
        const volumeValue = document.getElementById('volume-value');
        const fluorescentBuzz = document.getElementById('fluorescent-buzz');
        const mobileControls = document.getElementById('mobile-controls');
        const joystickContainer = document.getElementById('joystick-container');
        const joystick = document.getElementById('joystick');
        const runButton = document.getElementById('run-button');
        const crouchButton = document.getElementById('crouch-button');
        const actionButton = document.getElementById('action-button');
        const mobileControlsToggle = document.getElementById('mobile-controls-toggle');
        
        // Detect if device is mobile
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        
        // Variables for mobile controls
        let joystickActive = false;
        let joystickTouchId = null;
        let joystickPosition = { x: 0, y: 0 };
        let lookTouchId = null;
        let previousTouchX = 0;
        let previousTouchY = 0;
        let touchLookSensitivity = 0.1;
        
        // Game state variables
        let gameStarted = false;
        let audioInitialized = false;
        let isChatting = false;
        
        // Multiplayer variables
        let peer;
        let connection;
        let isHost = false;
        let isConnected = false;
        let remotePlayerModel;
        let remotePlayerPosition = new THREE.Vector3();
        let remotePlayerRotation = new THREE.Euler();
        let remotePlayerQuaternion = new THREE.Quaternion(); // Add quaternion for better rotation handling
        let remotePlayerMoving = false;
        let remotePlayerMovingBackward = false; // Add this new variable
        let remotePlayerLastPosition = new THREE.Vector3();
        let remotePlayerMixer;
        let remotePlayerWalkAction;
        let remotePlayerIdleAction;
        let remotePlayerBackflipAction; // Add new variable for backflip animation
        let isLocalPlayerBackflipping = false; // Flag to track if local player is backflipping
        let isRemotePlayerBackflipping = false; // Flag to track if remote player is backflipping
        let backflipStartTime = 0; // Track when backflip started
        let backflipDuration = 1.0; // Duration of backflip animation in seconds
        let lastDataSentTime = 0;
        const DATA_SEND_INTERVAL = 0.05; // Send data 20 times per second
        let directionHelper; // Debug helper to show remote player direction
        let showDirectionHelper = true; // Toggle for direction helper
        const animationCrossfadeTime = 0.3; // Time in seconds for animation crossfade
        
        const VHSShader = {
            uniforms: {
                "tDiffuse": { value: null },
                "time": { value: 0.0 },
                "distortion": { value: 0.8 },
                "noise": { value: 0.5 },
                "lineSpeed": { value: 0.6 }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform sampler2D tDiffuse;
                uniform float time;
                uniform float distortion;
                uniform float noise;
                uniform float lineSpeed;
                varying vec2 vUv;

                float random(vec2 st) {
                    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
                }

                void main() {
                    vec2 uv = vUv;
                    float verticalDisplace = sin(uv.y * 10.0 + time * lineSpeed) * 0.0008;
                    uv.x += verticalDisplace * distortion;

                    vec4 baseColor = texture2D(tDiffuse, uv);
                    float r = texture2D(tDiffuse, uv + vec2(0.003, 0.0) * distortion).r;
                    float g = baseColor.g;
                    float b = texture2D(tDiffuse, uv - vec2(0.003, 0.0) * distortion).b;

                    float noiseValue = random(uv + vec2(time * 0.1));
                    vec4 color = vec4(r, g, b, 1.0);
                    color.rgb = mix(color.rgb, vec3(noiseValue), noise * 0.08);

                    float scanline = sin(uv.y * 900.0 + time * 5.0) * 0.015;
                    color.rgb += scanline;

                    float glitchTime = floor(time * 0.8);
                    float glitchPos = random(vec2(glitchTime));
                    if (random(vec2(glitchTime * 0.1)) > 0.99 && 
                        abs(uv.y - glitchPos) < 0.03) {
                        uv.x += (random(vec2(glitchTime)) * 2.0 - 1.0) * 0.03;
                        color = texture2D(tDiffuse, uv);
                    }

                    gl_FragColor = color;
                }
            `
        };

        class UnionFind {
            constructor(size) {
                this.parent = new Array(size);
                this.rank = new Array(size);
                for (let i = 0; i < size; i++) {
                    this.parent[i] = i;
                    this.rank[i] = 0;
                }
            }
            find(x) {
                if (this.parent[x] !== x) {
                    this.parent[x] = this.find(this.parent[x]);
                }
                return this.parent[x];
            }
            union(x, y) {
                let rootX = this.find(x);
                let rootY = this.find(y);
                if (rootX === rootY) return false;
                if (this.rank[rootX] < this.rank[rootY]) {
                    this.parent[rootX] = rootY;
                } else if (this.rank[rootX] > this.rank[rootY]) {
                    this.parent[rootY] = rootX;
                } else {
                    this.parent[rootY] = rootX;
                    this.rank[rootX]++;
                }
                return true;
            }
        }

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.0;
        document.body.appendChild(renderer.domElement);

        const composer = new EffectComposer(renderer);
        const renderPass = new RenderPass(scene, camera);
        composer.addPass(renderPass);

        const vhsPass = new ShaderPass(VHSShader);
        composer.addPass(vhsPass);

        const cameraContainer = new THREE.Object3D();
        scene.add(cameraContainer);
        cameraContainer.add(camera);
        camera.position.set(0, 0, 0);

        // Initialize controls
        const controls = new PointerLockControls(cameraContainer, renderer.domElement);
        
        // Setup for mobile
        if (isMobile) {
            // Show mobile controls
            mobileControls.style.display = 'block';
            mobileControlsToggle.style.display = 'block';
            
            // Initialize joystick position
            const joystickRect = joystickContainer.getBoundingClientRect();
            joystickPosition = {
                x: joystickRect.left + joystickRect.width / 2,
                y: joystickRect.top + joystickRect.height / 2
            };
            
            // Setup mobile control event listeners
            setupMobileControls();
        }
        
        // Setup mobile controls
        function setupMobileControls() {
            // Joystick touch events
            joystickContainer.addEventListener('touchstart', handleJoystickStart, false);
            joystickContainer.addEventListener('touchmove', handleJoystickMove, false);
            joystickContainer.addEventListener('touchend', handleJoystickEnd, false);
            
            // Look touch events (anywhere except UI elements and joystick)
            document.addEventListener('touchstart', handleLookStart, false);
            document.addEventListener('touchmove', handleLookMove, false);
            document.addEventListener('touchend', handleLookEnd, false);
            
            // Action buttons
            runButton.addEventListener('touchstart', () => {
                isRunning = true;
                runButton.classList.add('active');
            });
            
            runButton.addEventListener('touchend', () => {
                isRunning = false;
                runButton.classList.remove('active');
            });
            
            crouchButton.addEventListener('touchstart', () => {
                if (!isCrouching) {
                    isCrouching = true;
                    camera.position.y -= 0.5;
                    playerPosition.y -= 0.5;
                    crouchButton.classList.add('active');
                }
            });
            
            crouchButton.addEventListener('touchend', () => {
                if (isCrouching) {
                    isCrouching = false;
                    camera.position.y += 0.5;
                    playerPosition.y += 0.5;
                    crouchButton.classList.remove('active');
                }
            });
            
            actionButton.addEventListener('touchstart', () => {
                // Trigger backflip
                if (!isLocalPlayerBackflipping && remotePlayerBackflipAction) {
                    isLocalPlayerBackflipping = true;
                    backflipStartTime = clock.getElapsedTime();
                    
                    // Play backflip animation on local player's model
                    if (remotePlayerBackflipAction) {
                        // Reset weights of other animations
                        if (remotePlayerIdleAction) remotePlayerIdleAction.weight = 0;
                        if (remotePlayerWalkAction) remotePlayerWalkAction.weight = 0;
                        
                        // Set backflip animation weight to 1
                        remotePlayerBackflipAction.reset();
                        remotePlayerBackflipAction.weight = 1;
                        remotePlayerBackflipAction.play();
                    }
                    
                    // Send backflip event to other player if connected
                    if (isConnected && connection) {
                        connection.send({
                            type: 'backflip',
                            startTime: backflipStartTime
                        });
                        
                        // Add chat message
                        addChatMessage('You did a backflip!', 'system');
                    }
                    
                    actionButton.classList.add('active');
                    setTimeout(() => {
                        actionButton.classList.remove('active');
                    }, backflipDuration * 1000);
                }
            });
            
            // Toggle mobile controls visibility
            mobileControlsToggle.addEventListener('click', () => {
                if (mobileControls.style.display === 'none') {
                    mobileControls.style.display = 'block';
                } else {
                    mobileControls.style.display = 'none';
                }
            });
        }
        
        // Handle joystick touch start
        function handleJoystickStart(event) {
            event.preventDefault();
            if (!joystickActive) {
                const touch = event.touches[0];
                joystickTouchId = touch.identifier;
                joystickActive = true;
                updateJoystickPosition(touch.clientX, touch.clientY);
            }
        }
        
        // Handle joystick touch move
        function handleJoystickMove(event) {
            event.preventDefault();
            if (joystickActive) {
                for (let i = 0; i < event.touches.length; i++) {
                    const touch = event.touches[i];
                    if (touch.identifier === joystickTouchId) {
                        updateJoystickPosition(touch.clientX, touch.clientY);
                        break;
                    }
                }
            }
        }
        
        // Handle joystick touch end
        function handleJoystickEnd(event) {
            event.preventDefault();
            let touchFound = false;
            
            // Check if our tracked touch is still active
            for (let i = 0; i < event.touches.length; i++) {
                if (event.touches[i].identifier === joystickTouchId) {
                    touchFound = true;
                    break;
                }
            }
            
            if (!touchFound) {
                // Reset joystick
                joystickActive = false;
                joystick.style.transform = 'translate(-50%, -50%)';
                
                // Reset movement flags
                moveForward = false;
                moveBackward = false;
                moveLeft = false;
                moveRight = false;
            }
        }
        
        // Update joystick position and movement flags
        function updateJoystickPosition(touchX, touchY) {
            const joystickRect = joystickContainer.getBoundingClientRect();
            const centerX = joystickRect.left + joystickRect.width / 2;
            const centerY = joystickRect.top + joystickRect.height / 2;
            
            // Calculate distance from center
            let deltaX = touchX - centerX;
            let deltaY = touchY - centerY;
            
            // Limit joystick movement to container radius
            const maxRadius = joystickRect.width / 2 - joystick.offsetWidth / 2;
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            
            if (distance > maxRadius) {
                const angle = Math.atan2(deltaY, deltaX);
                deltaX = Math.cos(angle) * maxRadius;
                deltaY = Math.sin(angle) * maxRadius;
            }
            
            // Update joystick visual position
            joystick.style.transform = `translate(calc(-50% + ${deltaX}px), calc(-50% + ${deltaY}px))`;
            
            // Normalize for movement (values between -1 and 1)
            const normalizedX = deltaX / maxRadius;
            const normalizedY = deltaY / maxRadius;
            
            // Set movement flags based on joystick position
            const deadzone = 0.2;
            moveForward = normalizedY < -deadzone;
            moveBackward = normalizedY > deadzone;
            moveLeft = normalizedX < -deadzone;
            moveRight = normalizedX > deadzone;
        }
        
        // Handle look touch start
        function handleLookStart(event) {
            if (joystickActive || !gameStarted || isChatting) return;
            
            // Find a touch that's not on the joystick or UI elements
            for (let i = 0; i < event.touches.length; i++) {
                const touch = event.touches[i];
                
                // Skip if this touch is already being used for joystick
                if (touch.identifier === joystickTouchId) continue;
                
                // Check if touch is on a UI element
                const element = document.elementFromPoint(touch.clientX, touch.clientY);
                const isUIElement = element.closest('#joystick-container, #mobile-action-buttons, #multiplayer-ui, #chat-container, #voice-chat-controls, #mobile-controls-toggle');
                
                if (!isUIElement) {
                    lookTouchId = touch.identifier;
                    previousTouchX = touch.clientX;
                    previousTouchY = touch.clientY;
                    break;
                }
            }
        }
        
        // Handle look touch move
        function handleLookMove(event) {
            if (lookTouchId === null || !gameStarted || isChatting) return;
            
            for (let i = 0; i < event.touches.length; i++) {
                const touch = event.touches[i];
                if (touch.identifier === lookTouchId) {
                    // Calculate movement delta
                    const deltaX = touch.clientX - previousTouchX;
                    const deltaY = touch.clientY - previousTouchY;
                    
                    // Rotate camera based on touch movement
                    controls.rotateLeft(-deltaX * touchLookSensitivity * 0.002);
                    controls.rotateUp(-deltaY * touchLookSensitivity * 0.002);
                    
                    // Update previous position
                    previousTouchX = touch.clientX;
                    previousTouchY = touch.clientY;
                    break;
                }
            }
        }
        
        // Handle look touch end
        function handleLookEnd(event) {
            let touchFound = false;
            
            // Check if our tracked touch is still active
            for (let i = 0; i < event.touches.length; i++) {
                if (event.touches[i].identifier === lookTouchId) {
                    touchFound = true;
                    break;
                }
            }
            
            if (!touchFound) {
                lookTouchId = null;
            }
        }
        
        document.addEventListener('click', () => {
            if (!gameStarted) return;
            
            // Only lock controls on desktop
            if (!isMobile && !controls.isLocked) {
                controls.lock();
            }
        });
        
        controls.addEventListener('lock', () => {
            if (isChatting) return;
            document.getElementById('game-ui').style.display = 'block';
            document.getElementById('fps-counter').style.display = 'block';
            document.getElementById('audio-controls').style.display = 'block';
        });
        
        controls.addEventListener('unlock', () => {
            // On mobile, don't hide UI when controls are unlocked
            if (!isMobile && !isChatting) {
                document.getElementById('game-ui').style.display = 'none';
                document.getElementById('fps-counter').style.display = 'none';
                document.getElementById('audio-controls').style.display = 'none';
            }
        });

        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let isRunning = false;
        let isCrouching = false;
        let uiVisible = false;

        // fluorescentBuzz is now declared earlier in the code
        // const fluorescentBuzz = document.getElementById('fluorescent-buzz');
        
        const stepSounds = [];
        const STEP_COUNT = 12;
        
        for (let i = 1; i <= STEP_COUNT; i++) {
            const stepSound = new Audio(`steps/step${i}.mp3`);
            stepSound.preload = 'auto';
            stepSounds.push(stepSound);
        }
        
        // Remote player footstep sounds
        const remotePlayerStepSounds = [];
        for (let i = 1; i <= STEP_COUNT; i++) {
            const remoteStepSound = new Audio(`steps/step${i}.mp3`);
            remoteStepSound.preload = 'auto';
            // Make remote player steps slightly quieter than player steps
            remoteStepSound.volume = 0.4;
            remotePlayerStepSounds.push(remoteStepSound);
        }
        
        // These variables are now declared earlier in the code
        // const volumeSlider = document.getElementById('volume-slider');
        // const volumeValue = document.getElementById('volume-value');
        let masterVolume = 0.7;
        let footstepVolume = 0.5;
        let lastStepTime = 0;
        let lastStepIndex = -1;
        let lastRemoteStepTime = 0;
        let lastRemoteStepIndex = -1;
        
        fluorescentBuzz.volume = masterVolume;
        stepSounds.forEach(sound => {
            sound.volume = masterVolume * footstepVolume;
        });
        remotePlayerStepSounds.forEach(sound => {
            sound.volume = masterVolume * footstepVolume * 0.4; // Remote player steps are quieter
        });
        
        let audioContext;
        
        function initAudio() {
            if (audioInitialized) return;
            
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                if (audioContext.state === 'suspended') {
                    audioContext.resume();
                }
                
                fluorescentBuzz.play().then(() => {
                    console.log("Audio playback started successfully");
                    audioInitialized = true;
                }).catch(error => {
                    console.log("Audio playback failed:", error);
                });
            } catch (error) {
                console.error('Error initializing audio context:', error);
            }
        }
        
        function playFootstep() {
            if (!audioInitialized) return;
            
            const isAnyStepPlaying = stepSounds.some(sound => !sound.paused && sound.currentTime < sound.duration - 0.05);
            if (isAnyStepPlaying) return;
            
            let stepIndex;
            do {
                stepIndex = Math.floor(footstepRandom.random() * stepSounds.length);
            } while (stepIndex === lastStepIndex && stepSounds.length > 1);
            
            lastStepIndex = stepIndex;
            
            const stepSound = stepSounds[stepIndex];
            stepSound.currentTime = 0;
            stepSound.volume = masterVolume * footstepVolume;
            
            stepSound.play().catch(e => {
                console.log("Couldn't play step sound:", e);
            });
        }
        
        function playRemotePlayerFootstep() {
            if (!audioInitialized) return;
            
            const isAnyRemoteStepPlaying = remotePlayerStepSounds.some(sound => !sound.paused && sound.currentTime < sound.duration - 0.05);
            if (isAnyRemoteStepPlaying) return;
            
            let stepIndex;
            do {
                stepIndex = Math.floor(remoteFootstepRandom.random() * remotePlayerStepSounds.length);
            } while (stepIndex === lastRemoteStepIndex && remotePlayerStepSounds.length > 1);
            
            lastRemoteStepIndex = stepIndex;
            
            const stepSound = remotePlayerStepSounds[stepIndex];
            stepSound.currentTime = 0;
            stepSound.volume = masterVolume * footstepVolume * 0.4; // Quieter than player footsteps
            
            // Add slight pitch variation to differentiate from player footsteps
            const pitchVariation = 0.9 + remoteFootstepRandom.random() * 0.2; // Between 0.9 and 1.1
            stepSound.playbackRate = pitchVariation;
            
            stepSound.play().catch(e => {
                console.log("Couldn't play remote player step sound:", e);
            });
        }
        
        document.addEventListener('click', initAudio, { once: false });
        document.addEventListener('keydown', initAudio, { once: false });
        document.addEventListener('touchstart', initAudio, { once: false });
        
        volumeSlider.addEventListener('input', () => {
            masterVolume = volumeSlider.value / 100;
            volumeValue.textContent = `${volumeSlider.value}%`;
            fluorescentBuzz.volume = masterVolume;
            stepSounds.forEach(sound => {
                sound.volume = masterVolume * footstepVolume;
            });
            remotePlayerStepSounds.forEach(sound => {
                sound.volume = masterVolume * footstepVolume * 0.4;
            });
        });
        
        document.addEventListener('keydown', (event) => {
            if (!gameStarted) return;
            
            // If in chat mode, don't process movement keys
            if (isChatting) return;
            
            switch (event.code) {
                case 'KeyW': moveForward = true; break;
                case 'KeyS': moveBackward = true; break;
                case 'KeyA': moveLeft = true; break;
                case 'KeyD': moveRight = true; break;
                case 'ShiftLeft': 
                case 'ShiftRight': 
                    isRunning = true; 
                    break;
                case 'ControlLeft':
                case 'ControlRight':
                    if (!isCrouching) {
                        isCrouching = true;
                        camera.position.y -= 0.5;
                        playerPosition.y -= 0.5;
                    }
                    break;
                case 'KeyF':
                    // Trigger backflip animation if not already backflipping
                    if (!isLocalPlayerBackflipping && remotePlayerBackflipAction) {
                        isLocalPlayerBackflipping = true;
                        backflipStartTime = clock.getElapsedTime();
                        
                        // Play backflip animation on local player's model
                        if (remotePlayerBackflipAction) {
                            // Reset weights of other animations
                            if (remotePlayerIdleAction) remotePlayerIdleAction.weight = 0;
                            if (remotePlayerWalkAction) remotePlayerWalkAction.weight = 0;
                            
                            // Set backflip animation weight to 1
                            remotePlayerBackflipAction.reset();
                            remotePlayerBackflipAction.weight = 1;
                            remotePlayerBackflipAction.play();
                        }
                        
                        // Send backflip event to other player if connected
                        if (isConnected && connection) {
                            connection.send({
                                type: 'backflip',
                                startTime: backflipStartTime
                            });
                            
                            // Add chat message
                            addChatMessage('You did a backflip!', 'system');
                        }
                    }
                    break;
                case 'KeyH':
                    uiVisible = !uiVisible;
                    document.getElementById('game-ui').style.display = uiVisible ? 'block' : 'none';
                    document.getElementById('fps-counter').style.display = uiVisible ? 'block' : 'none';
                    document.getElementById('audio-controls').style.display = uiVisible ? 'block' : 'none';
                    break;
                case 'KeyM':
                    fluorescentBuzz.muted = !fluorescentBuzz.muted;
                    break;
                case 'KeyR':
                    if (fluorescentBuzz.paused) {
                        fluorescentBuzz.play().catch(e => console.log("Couldn't restart audio:", e));
                    }
                    break;
                case 'KeyT':
                    // Enter chat mode
                    if (isConnected) {
                        isChatting = true;
                        controls.unlock();
                        chatContainer.style.display = 'block';
                        chatInput.focus();
                    } else {
                        addChatMessage('Not connected to another player', 'system');
                    }
                    break;
                case 'KeyV':
                    // Toggle direction helper visibility
                    if (directionHelper) {
                        showDirectionHelper = !showDirectionHelper;
                        directionHelper.visible = showDirectionHelper;
                        addChatMessage(`Direction helper ${showDirectionHelper ? 'shown' : 'hidden'}`, 'system');
                    }
                    break;
                case 'KeyB':
                    voiceChatToggle.click();
                    break;
            }
        });
        
        document.addEventListener('keyup', (event) => {
            if (!gameStarted) return;
            
            switch (event.code) {
                case 'KeyW': moveForward = false; break;
                case 'KeyS': moveBackward = false; break;
                case 'KeyA': moveLeft = false; break;
                case 'KeyD': moveRight = false; break;
                case 'ShiftLeft': 
                case 'ShiftRight': 
                    isRunning = false; 
                    break;
                case 'ControlLeft':
                case 'ControlRight':
                    if (isCrouching) {
                        isCrouching = false;
                        camera.position.y += 0.5;
                        playerPosition.y += 0.5;
                    }
                    break;
            }
        });

        const clock = new THREE.Clock();
        const walls = [];

        const N = 10;
        const M = 10;
        const roomSize = 6;

        // Create a seeded random number generator for consistent maze generation
        class SeededRandom {
            constructor(seed = 12345) {
                this.seed = seed;
            }
            
            // Simple random function that uses the seed
            random() {
                const x = Math.sin(this.seed++) * 10000;
                return x - Math.floor(x);
            }
        }
        
        // Create fixed-seed random generators for different purposes
        const mazeRandom = new SeededRandom(12345);
        const audioRandom = new SeededRandom(24680);
        const footstepRandom = new SeededRandom(13579);
        const remoteFootstepRandom = new SeededRandom(97531);

        const horizontalWalls = Array.from({ length: N - 1 }, () => Array(M).fill(true));
        const verticalWalls = Array.from({ length: N }, () => Array(M - 1).fill(true));

        const wallList = [];
        for (let k = 0; k < N - 1; k++) {
            for (let j = 0; j < M; j++) {
                const roomA = k * M + j;
                const roomB = (k + 1) * M + j;
                wallList.push({ type: 'horizontal', k, j, rooms: [roomA, roomB] });
            }
        }
        for (let i = 0; i < N; i++) {
            for (let l = 0; l < M - 1; l++) {
                const roomA = i * M + l;
                const roomB = i * M + (l + 1);
                wallList.push({ type: 'vertical', i, l, rooms: [roomA, roomB] });
            }
        }

        // Use the seeded random for shuffling the wall list
        for (let i = wallList.length - 1; i > 0; i--) {
            const j = Math.floor(mazeRandom.random() * (i + 1));
            [wallList[i], wallList[j]] = [wallList[j], wallList[i]];
        }

        const uf = new UnionFind(N * M);
        let components = N * M;
        let index = 0;
        while (components > 1 && index < wallList.length) {
            const wall = wallList[index];
            const [roomA, roomB] = wall.rooms;
            if (uf.union(roomA, roomB)) {
                if (wall.type === 'horizontal') {
                    horizontalWalls[wall.k][wall.j] = false;
                } else {
                    verticalWalls[wall.i][wall.l] = false;
                }
                components--;
            }
            index++;
        }

        // Use seeded random for additional wall removal
        for (let k = 0; k < N - 1; k++) {
            for (let j = 0; j < M; j++) {
                if (horizontalWalls[k][j] && mazeRandom.random() < 0.08) {
                    horizontalWalls[k][j] = false;
                }
            }
        }
        for (let i = 0; i < N; i++) {
            for (let l = 0; l < M - 1; l++) {
                if (verticalWalls[i][l] && mazeRandom.random() < 0.08) {
                    verticalWalls[i][l] = false;
                }
            }
        }

        const createWallpaperTexture = () => {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const size = 512;
            canvas.width = size;
            canvas.height = size;

            ctx.fillStyle = '#e9e566';
            ctx.fillRect(0, 0, size, size);

            const stripeWidth = size / 20;
            ctx.fillStyle = '#d6d259';
            for (let i = 0; i < 20; i += 2) {
                ctx.fillRect(i * stripeWidth, 0, stripeWidth, size);
            }

            ctx.fillStyle = '#c8c44d';
            const thinLineWidth = stripeWidth * 0.2;
            for (let i = 1; i < 20; i += 2) {
                const xPos = i * stripeWidth + (stripeWidth - thinLineWidth) / 2;
                ctx.fillRect(xPos, 0, thinLineWidth, size);
            }

            const arrowHeight = size / 25;
            const arrowWidth = stripeWidth * 0.8;
            ctx.fillStyle = '#c8c44d';

            for (let y = 0; y < size; y += arrowHeight * 2) {
                for (let x = stripeWidth / 2; x < size; x += stripeWidth * 2) {
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(x + arrowWidth / 2, y + arrowHeight);
                    ctx.lineTo(x, y + arrowHeight * 2);
                    ctx.lineTo(x - arrowWidth / 2, y + arrowHeight);
                    ctx.closePath();
                    ctx.fill();
                }
            }

            return new THREE.CanvasTexture(canvas);
        };

        const createCeilingTexture = () => {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const size = 512;
            canvas.width = size;
            canvas.height = size;

            ctx.fillStyle = '#fffacd';
            ctx.fillRect(0, 0, size, size);

            ctx.strokeStyle = '#d6d259';
            ctx.lineWidth = 2;
            const gridCount = 8;
            const gridSize = size / gridCount;

            for (let i = 0; i <= gridCount; i++) {
                ctx.beginPath();
                ctx.moveTo(0, i * gridSize);
                ctx.lineTo(size, i * gridSize);
                ctx.stroke();
            }

            for (let i = 0; i <= gridCount; i++) {
                ctx.beginPath();
                ctx.moveTo(i * gridSize, 0);
                ctx.lineTo(i * gridSize, size);
                ctx.stroke();
            }

            return new THREE.CanvasTexture(canvas);
        };

        const createNormalMap = () => {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const size = 512;
            canvas.width = size;
            canvas.height = size;

            ctx.fillStyle = '#8080ff';
            ctx.fillRect(0, 0, size, size);

            // Use seeded random for normal map generation
            const textureRandom = new SeededRandom(54321);

            for (let i = 0; i < 200; i++) {
                const x = textureRandom.random() * size;
                const y = textureRandom.random() * size;
                const radius = 2 + textureRandom.random() * 5;

                const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
                gradient.addColorStop(0, '#7878ff');
                gradient.addColorStop(1, '#8080ff');

                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
            }

            return new THREE.CanvasTexture(canvas);
        };

        const createFloorTexture = () => {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const size = 512;
            canvas.width = size;
            canvas.height = size;

            ctx.fillStyle = '#a68f3e';
            ctx.fillRect(0, 0, size, size);

            // Use seeded random for floor texture generation
            const textureRandom = new SeededRandom(67890);

            const imageData = ctx.getImageData(0, 0, size, size);
            const data = imageData.data;
            for (let i = 0; i < data.length; i += 4) {
                const noise = (textureRandom.random() - 0.5) * 10;
                data[i]   += noise;
                data[i+1] += noise;
                data[i+2] += noise;
            }
            ctx.putImageData(imageData, 0, 0);

            return new THREE.CanvasTexture(canvas);
        };

        const createFloorNormalMap = () => {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const size = 512;
            canvas.width = size;
            canvas.height = size;

            ctx.fillStyle = '#8080ff';
            ctx.fillRect(0, 0, size, size);

            // Use seeded random for floor normal map generation
            const textureRandom = new SeededRandom(98765);

            for (let i = 0; i < 200; i++) {
                const x = textureRandom.random() * size;
                const y = textureRandom.random() * size;
                const radius = 2 + textureRandom.random() * 8;

                const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
                gradient.addColorStop(0, '#7878ff');
                gradient.addColorStop(1, '#8080ff');

                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
            }

            return new THREE.CanvasTexture(canvas);
        };

        const wallTexture = createWallpaperTexture();
        wallTexture.wrapS = THREE.RepeatWrapping;
        wallTexture.wrapT = THREE.RepeatWrapping;
        wallTexture.repeat.set(2, 1);

        const ceilingTexture = createCeilingTexture();
        ceilingTexture.wrapS = THREE.RepeatWrapping;
        ceilingTexture.wrapT = THREE.RepeatWrapping;
        ceilingTexture.repeat.set(M, N);

        const normalMap = createNormalMap();

        const floorTexture = createFloorTexture();
        floorTexture.wrapS = THREE.RepeatWrapping;
        floorTexture.wrapT = THREE.RepeatWrapping;
        floorTexture.repeat.set(N, N);

        const floorNormalMap = createFloorNormalMap();
        floorNormalMap.wrapS = THREE.RepeatWrapping;
        floorNormalMap.wrapT = THREE.RepeatWrapping;
        floorNormalMap.repeat.set(N, N);

        const wallMaterial = new THREE.MeshStandardMaterial({
            map: wallTexture,
            normalMap: normalMap,
            normalScale: new THREE.Vector2(0.5, 0.5),
            roughness: 0.7,
            metalness: 0.1,
            envMapIntensity: 1.0,
            color: 0xffffff
        });

        const startingRoomWidth = 10;
        const startingRoomDepth = 10;
        const hallwayWidth = 4;
        const hallwayLength = 100;

        function createStartingRoom() {
            const roomWalls = [
                new THREE.Mesh(
                    new THREE.BoxGeometry(0.3, 5, startingRoomDepth),
                    wallMaterial
                ),
                new THREE.Mesh(
                    new THREE.BoxGeometry(0.3, 5, startingRoomDepth),
                    wallMaterial
                ),
                new THREE.Mesh(
                    new THREE.BoxGeometry(startingRoomWidth, 5, 0.3),
                    wallMaterial
                ),
                new THREE.Mesh(
                    new THREE.BoxGeometry((startingRoomWidth - hallwayWidth) / 2, 5, 0.3),
                    wallMaterial
                ),
                new THREE.Mesh(
                    new THREE.BoxGeometry((startingRoomWidth - hallwayWidth) / 2, 5, 0.3),
                    wallMaterial
                )
            ];

            roomWalls[0].position.set(0, 2.5, startingRoomDepth / 2);
            roomWalls[1].position.set(startingRoomWidth, 2.5, startingRoomDepth / 2);
            roomWalls[2].position.set(startingRoomWidth / 2, 2.5, 0);
            roomWalls[3].position.set((startingRoomWidth - hallwayWidth) / 4, 2.5, startingRoomDepth);
            roomWalls[4].position.set(startingRoomWidth - (startingRoomWidth - hallwayWidth) / 4, 2.5, startingRoomDepth);

            roomWalls.forEach(wall => {
                scene.add(wall);
                walls.push(wall);
            });

            return roomWalls;
        }

        function createHallway() {
            const hallwayWalls = [
                new THREE.Mesh(
                    new THREE.BoxGeometry(0.3, 5, hallwayLength),
                    wallMaterial
                ),
                new THREE.Mesh(
                    new THREE.BoxGeometry(0.3, 5, hallwayLength),
                    wallMaterial
                )
            ];

            const hallwayStartZ = startingRoomDepth;
            const hallwayStartX = (startingRoomWidth - hallwayWidth) / 2;
            
            hallwayWalls[0].position.set(hallwayStartX, 2.5, hallwayStartZ + hallwayLength / 2);
            hallwayWalls[1].position.set(hallwayStartX + hallwayWidth, 2.5, hallwayStartZ + hallwayLength / 2);

            hallwayWalls.forEach(wall => {
                scene.add(wall);
                walls.push(wall);
            });

            return hallwayWalls;
        }

        const mazeOffsetZ = startingRoomDepth + hallwayLength;
        const hallwayEndX = (startingRoomWidth - hallwayWidth) / 2;
        const hallwayCenterX = hallwayEndX + hallwayWidth / 2;
        
        const outerWalls = [];
        
        if (hallwayEndX > 0) {
            const leftWall = new THREE.Mesh(
                new THREE.BoxGeometry(hallwayEndX, 5, 0.3),
                wallMaterial
            );
            leftWall.position.set(hallwayEndX / 2, 2.5, mazeOffsetZ);
            scene.add(leftWall);
            walls.push(leftWall);
            outerWalls.push(leftWall);
        }
        
        const rightStartX = hallwayEndX + hallwayWidth;
        if (rightStartX < M * roomSize) {
            const rightWall = new THREE.Mesh(
                new THREE.BoxGeometry(M * roomSize - rightStartX, 5, 0.3),
                wallMaterial
            );
            rightWall.position.set(rightStartX + (M * roomSize - rightStartX) / 2, 2.5, mazeOffsetZ);
            scene.add(rightWall);
            walls.push(rightWall);
            outerWalls.push(rightWall);
        }
        
        const backWall = new THREE.Mesh(
            new THREE.BoxGeometry(M * roomSize, 5, 0.3),
            wallMaterial
        );
        backWall.position.set(M * roomSize / 2, 2.5, mazeOffsetZ + N * roomSize);
        scene.add(backWall);
        walls.push(backWall);
        outerWalls.push(backWall);
        
        const leftSideWall = new THREE.Mesh(
            new THREE.BoxGeometry(0.3, 5, N * roomSize),
            wallMaterial
        );
        leftSideWall.position.set(0, 2.5, mazeOffsetZ + N * roomSize / 2);
        scene.add(leftSideWall);
        walls.push(leftSideWall);
        outerWalls.push(leftSideWall);
        
        const rightSideWall = new THREE.Mesh(
            new THREE.BoxGeometry(0.3, 5, N * roomSize),
            wallMaterial
        );
        rightSideWall.position.set(M * roomSize, 2.5, mazeOffsetZ + N * roomSize / 2);
        scene.add(rightSideWall);
        walls.push(rightSideWall);
        outerWalls.push(rightSideWall);
        
        if (hallwayEndX > 0 || hallwayEndX + hallwayWidth < M * roomSize) {
            const leftTransWall = new THREE.Mesh(
                new THREE.BoxGeometry(0.3, 5, 2),
                wallMaterial
            );
            leftTransWall.position.set(hallwayEndX, 2.5, mazeOffsetZ + 1);
            scene.add(leftTransWall);
            walls.push(leftTransWall);
            
            const rightTransWall = new THREE.Mesh(
                new THREE.BoxGeometry(0.3, 5, 2),
                wallMaterial
            );
            rightTransWall.position.set(hallwayEndX + hallwayWidth, 2.5, mazeOffsetZ + 1);
            scene.add(rightTransWall);
            walls.push(rightTransWall);
        }

        for (let k = 0; k < N - 1; k++) {
            for (let j = 0; j < M; j++) {
                if (horizontalWalls[k][j]) {
                    const wall = new THREE.Mesh(
                        new THREE.BoxGeometry(roomSize, 5, 0.3),
                        wallMaterial
                    );
                    wall.position.set((j + 0.5) * roomSize, 2.5, mazeOffsetZ + (k + 1) * roomSize);
                    scene.add(wall);
                    walls.push(wall);
                }
            }
        }

        for (let i = 0; i < N; i++) {
            for (let l = 0; l < M - 1; l++) {
                if (verticalWalls[i][l]) {
                    const wall = new THREE.Mesh(
                        new THREE.BoxGeometry(0.3, 5, roomSize),
                        wallMaterial
                    );
                    wall.position.set((l + 1) * roomSize, 2.5, mazeOffsetZ + (i + 0.5) * roomSize);
                    scene.add(wall);
                    walls.push(wall);
                }
            }
        }

        createStartingRoom();
        createHallway();

        walls.forEach(wall => {
            wall.geometry.computeBoundingBox();
            wall.updateMatrixWorld(true);
            wall.worldBoundingBox = new THREE.Box3().copy(wall.geometry.boundingBox).applyMatrix4(wall.matrixWorld);
        });

        const mapWidth = Math.max(startingRoomWidth, M * roomSize);
        const mapDepth = startingRoomDepth + hallwayLength + N * roomSize;
        const floorSize = Math.max(mapWidth, mapDepth) + 20;

        const floorMaterial = new THREE.MeshStandardMaterial({
            map: floorTexture,
            normalMap: floorNormalMap,
            normalScale: new THREE.Vector2(0.5, 0.5),
            roughness: 0.9,
            metalness: 0.1,
            envMapIntensity: 1.0
        });

        const ceilingMaterial = new THREE.MeshStandardMaterial({
            map: ceilingTexture,
            color: 0xf5e6a3,
            roughness: 0.9,
            metalness: 0.0,
            envMapIntensity: 1.0
        });

        const floor = new THREE.Mesh(
            new THREE.PlaneGeometry(floorSize, floorSize),
            floorMaterial
        );
        floor.rotation.x = -Math.PI / 2;
        floor.position.set(floorSize / 2, 0, floorSize / 2);
        scene.add(floor);

        const ceiling = new THREE.Mesh(
            new THREE.PlaneGeometry(floorSize, floorSize),
            ceilingMaterial
        );
        ceiling.rotation.x = Math.PI / 2;
        ceiling.position.set(floorSize / 2, 5, floorSize / 2);
        scene.add(ceiling);

        const lights = [];
        for (let i = 0; i < N; i++) {
            for (let j = 0; j < M; j++) {
                const lightGeometry = new THREE.PlaneGeometry(1.5, 1.5);
                const lightMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    side: THREE.DoubleSide
                });

                const lightPanel = new THREE.Mesh(lightGeometry, lightMaterial);
                lightPanel.position.set((j + 0.5) * roomSize, 4.99, mazeOffsetZ + (i + 0.5) * roomSize);
                lightPanel.rotation.x = Math.PI / 2;
                scene.add(lightPanel);

                const light = new THREE.PointLight(0xffffee, 7, 20);
                light.position.set((j + 0.5) * roomSize, 4.5, mazeOffsetZ + (i + 0.5) * roomSize);
                scene.add(light);
                lights.push(light);
            }
        }

        for (let x = 2; x < startingRoomWidth; x += 4) {
            for (let z = 2; z < startingRoomDepth; z += 4) {
                const lightGeometry = new THREE.PlaneGeometry(1.5, 1.5);
                const lightMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    side: THREE.DoubleSide
                });

                const lightPanel = new THREE.Mesh(lightGeometry, lightMaterial);
                lightPanel.position.set(x, 4.99, z);
                lightPanel.rotation.x = Math.PI / 2;
                scene.add(lightPanel);

                const light = new THREE.PointLight(0xffffee, 7, 20);
                light.position.set(x, 4.5, z);
                scene.add(light);
                lights.push(light);
            }
        }

        const hallwayStartZ = startingRoomDepth;
        const hallwayStartX = (startingRoomWidth - hallwayWidth) / 2;
        for (let z = hallwayStartZ + 4; z < hallwayStartZ + hallwayLength; z += 6) {
            const x = hallwayStartX + hallwayWidth / 2;
            
            const lightGeometry = new THREE.PlaneGeometry(1.5, 1.5);
            const lightMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                side: THREE.DoubleSide
            });

            const lightPanel = new THREE.Mesh(lightGeometry, lightMaterial);
            lightPanel.position.set(x, 4.99, z);
            lightPanel.rotation.x = Math.PI / 2;
            scene.add(lightPanel);

            const light = new THREE.PointLight(0xffffee, 7, 20);
            light.position.set(x, 4.5, z);
            scene.add(light);
            lights.push(light);
        }

        let playerPosition = new THREE.Vector3(startingRoomWidth / 2, 2.0, startingRoomDepth / 2);
        const offset = new THREE.Vector3(0, 0, 0);
        let currentIntensity = 0.005;
        const restingIntensity = 0.005;
        const movingIntensity = 0.25;
        const runningIntensity = 0.4;
        const crouchingIntensity = 0.15;
        const transitionSpeed = 5;
        const playerRadius = 0.3;
        const remotePlayerRadius = 0.3;
        let remotePlayerYOffset = -0.01; // Small offset to ensure model appears grounded
        
        let walkCycle = 0;
        const walkFrequency = 7.0;
        const walkAmplitude = 0.09;
        const headBobAmplitude = 0.03;
        const walkLeanAmount = 0.07;
        const cameraRollAmount = 0.02;
        
        const walkSpeed = 5;
        const runSpeed = 8;
        const crouchSpeed = 2.5;
        
        let bobFactor = 0;
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });
        
        let frameCount = 0;
        let lastTime = 0;
        let fps = 0;
        
        let loadingProgressValue = 0;
        const loadingInterval = setInterval(() => {
            // Use fixed increments instead of random for consistent loading experience
            loadingProgressValue += 5;
            if (loadingProgressValue >= 100) {
                loadingProgressValue = 100;
                clearInterval(loadingInterval);
                
                loadingBar.style.width = '100%';
                loadingProgressElement.textContent = '100%';
                
                startButton.style.display = 'block';
            } else {
                loadingBar.style.width = `${loadingProgressValue}%`;
                loadingProgressElement.textContent = `${Math.floor(loadingProgressValue)}%`;
            }
        }, 200);

        function checkCollision(position, radius) {
            const sphere = new THREE.Sphere(position, radius);
            for (const wall of walls) {
                if (wall.worldBoundingBox && wall.worldBoundingBox.intersectsSphere(sphere)) {
                    return true;
                }
            }
            return false;
        }
        
        // Find a valid direction for the companion to move when stuck
        function findValidDirection(position, radius, preferredDirection, numAttempts = 8) {
            // First try the preferred direction
            if (!checkCollision(position.clone().add(preferredDirection.clone().multiplyScalar(radius * 2)), radius)) {
                return preferredDirection.clone();
            }
            
            // Try various angles around the circle
            const angleStep = (Math.PI * 2) / numAttempts;
            for (let i = 0; i < numAttempts; i++) {
                const angle = i * angleStep;
                const direction = new THREE.Vector3(
                    Math.cos(angle),
                    0,
                    Math.sin(angle)
                ).normalize();
                
                const testPosition = position.clone().add(direction.clone().multiplyScalar(radius * 2));
                if (!checkCollision(testPosition, radius)) {
                    return direction;
                }
            }
            
            // If all else fails, return a random direction
            const randomDir = new THREE.Vector3(
                Math.random() - 0.5,
                0,
                Math.random() - 0.5
            ).normalize();
            
            return randomDir;
        }

        function sendPlayerData() {
            if (isConnected && connection) {
                const isMoving = moveForward || moveBackward || moveLeft || moveRight;
                const isMovingBackward = moveBackward;
                
                // Create a quaternion from the camera container's rotation
                const quaternion = new THREE.Quaternion();
                cameraContainer.getWorldQuaternion(quaternion);
                
                connection.send({
                    type: 'position',
                    position: {
                        x: playerPosition.x,
                        y: playerPosition.y,
                        z: playerPosition.z
                    },
                    quaternion: {
                        x: quaternion.x,
                        y: quaternion.y,
                        z: quaternion.z,
                        w: quaternion.w
                    },
                    isMoving: isMoving,
                    isMovingBackward: isMovingBackward
                });
            }
        }

        function sendChatMessage(message) {
            if (isConnected && connection) {
                connection.send({
                    type: 'chat',
                    message: message
                });
                addChatMessage(message, 'self');
            }
        }

        function addChatMessage(message, type) {
            const messageElement = document.createElement('div');
            messageElement.classList.add('chat-message', type);
            
            if (type === 'self') {
                messageElement.textContent = `You: ${message}`;
            } else if (type === 'other') {
                messageElement.textContent = `Other: ${message}`;
            } else if (type === 'system') {
                messageElement.textContent = message;
            }
            
            chatMessages.appendChild(messageElement);
            chatMessages.scrollTop = chatMessages.scrollHeight;
            
            // Show chat container if it's hidden
            chatContainer.style.display = 'block';
            
            // Auto-hide system messages after 5 seconds
            if (type === 'system') {
                setTimeout(() => {
                    chatMessages.removeChild(messageElement);
                    
                    // Hide chat container if there are no messages
                    if (chatMessages.children.length === 0) {
                        chatContainer.style.display = 'none';
                    }
                }, 5000);
            }
        }

        // Initialize chat
        function initChat() {
            chatForm.addEventListener('submit', (e) => {
                e.preventDefault();
                
                const message = chatInput.value.trim();
                if (message) {
                    sendChatMessage(message);
                    chatInput.value = '';
                }
                
                // Exit chat mode
                isChatting = false;
                chatInput.blur();
                controls.lock();
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            
            frameCount++;
            const now = performance.now();
            if (now - lastTime >= 1000) {
                fps = Math.round((frameCount * 1000) / (now - lastTime));
                fpsCounter.textContent = `FPS: ${fps}`;
                frameCount = 0;
                lastTime = now;
            }
            
            if (!gameStarted) return;
            
            const delta = clock.getDelta();
            const currentTime = clock.getElapsedTime();
            
            // Send player data at regular intervals
            if (currentTime - lastDataSentTime >= DATA_SEND_INTERVAL) {
                sendPlayerData();
                lastDataSentTime = currentTime;
            }
            
            let speed = walkSpeed;
            if (isRunning && !isCrouching) {
                speed = runSpeed;
            } else if (isCrouching) {
                speed = crouchSpeed;
            }
            
            const distance = speed * delta;

            vhsPass.uniforms["time"].value += delta;

            const isMoving = moveForward || moveBackward || moveLeft || moveRight;
            
            if (isMoving && audioInitialized) {
                let stepInterval = 0.65;
                if (isRunning && !isCrouching) {
                    stepInterval = 0.45;
                } else if (isCrouching) {
                    stepInterval = 0.9;
                }
                
                if (currentTime - lastStepTime >= stepInterval) {
                    playFootstep();
                    lastStepTime = currentTime;
                }
            } else {
                lastStepTime = currentTime - 1.0;
            }
            
            let targetIntensity = restingIntensity;
            if (isMoving) {
                if (isRunning && !isCrouching) {
                    targetIntensity = runningIntensity;
                } else if (isCrouching) {
                    targetIntensity = crouchingIntensity;
                } else {
                    targetIntensity = movingIntensity;
                }
            }
            
            currentIntensity += (targetIntensity - currentIntensity) * transitionSpeed * delta;
            
            if (isMoving) {
                bobFactor = Math.min(bobFactor + delta * 2.5, 1);
            } else {
                bobFactor = Math.max(bobFactor - delta * 2.0, 0);
            }
            
            const cycleSpeed = walkFrequency * (isRunning && !isCrouching ? 1.5 : 1.0) * (isCrouching ? 0.7 : 1.0);
            walkCycle += cycleSpeed * delta;
            if (walkCycle > Math.PI * 2) {
                walkCycle -= Math.PI * 2;
            }
            
            offset.set(0, 0, 0);
            
            let amplitudeMultiplier = bobFactor;
            if (isRunning && !isCrouching) {
                amplitudeMultiplier *= 1.3;
            } else if (isCrouching) {
                amplitudeMultiplier *= 0.4;
            }
            
            offset.y = Math.sin(walkCycle) * walkAmplitude * amplitudeMultiplier;
            offset.x = Math.cos(walkCycle) * headBobAmplitude * amplitudeMultiplier;
            offset.z = Math.sin(walkCycle * 2) * walkLeanAmount * amplitudeMultiplier;
            
            const targetRoll = Math.sin(walkCycle * 1.5) * cameraRollAmount * amplitudeMultiplier;
            
            const randomScale = 0.003 * currentIntensity * (bobFactor * 0.8 + 0.2);
            offset.x += (Math.random() - 0.5) * randomScale * 1.5;
            offset.y += (Math.random() - 0.5) * randomScale * 1.5;
            offset.z += (Math.random() - 0.5) * randomScale * 1.5;
            
            if (bobFactor < 0.5) {
                const breathingStrength = (1 - bobFactor * 2) * 0.001;
                offset.y += Math.sin(clock.elapsedTime * 1.2) * breathingStrength;
            }

            const prevPlayerPosition = playerPosition.clone();

            if (moveForward)  controls.moveForward(distance);
            if (moveBackward) controls.moveForward(-distance);
            if (moveLeft)     controls.moveRight(-distance);
            if (moveRight)    controls.moveRight(distance);

            playerPosition.copy(cameraContainer.position);
            
            if (isCrouching) {
                playerPosition.y = 1.5;
            } else {
                playerPosition.y = 2.0;
            }
            cameraContainer.position.y = playerPosition.y;

            const playerSphere = new THREE.Sphere(playerPosition, playerRadius);
            let collision = false;
            
            for (const wall of walls) {
                if (wall.worldBoundingBox && wall.worldBoundingBox.intersectsSphere(playerSphere)) {
                    collision = true;
                    break;
                }
            }
            
            if (collision) {
                playerPosition.copy(prevPlayerPosition);
                cameraContainer.position.copy(playerPosition);
            }

            // Update remote player (replaces companion code)
            if (remotePlayerModel && remotePlayerMixer) {
                remotePlayerMixer.update(delta);
                
                // Calculate distance moved since last frame
                const distanceMoved = remotePlayerPosition.distanceTo(remotePlayerLastPosition);
                remotePlayerLastPosition.copy(remotePlayerPosition);
                
                // Update position - add Y offset to the model's position
                remotePlayerModel.position.set(
                    remotePlayerPosition.x,
                    remotePlayerYOffset, // Use Y offset for grounding
                    remotePlayerPosition.z
                );
                
                // Apply quaternion rotation directly
                // Extract only the Y-axis rotation (yaw) from the quaternion
                // This prevents the model from tilting up/down when the player looks up/down
                const euler = new THREE.Euler().setFromQuaternion(remotePlayerQuaternion, 'YXZ');
                const yawOnlyQuaternion = new THREE.Quaternion().setFromEuler(
                    new THREE.Euler(0, euler.y, 0, 'YXZ')
                );
                remotePlayerModel.quaternion.copy(yawOnlyQuaternion);
                
                // Log position and rotation occasionally for debugging
                if (Math.random() < 0.01) { // Log approximately once every 100 frames
                    console.log("Remote player update:", {
                        position: remotePlayerModel.position.clone(),
                        quaternion: remotePlayerQuaternion.clone(),
                        moving: remotePlayerMoving
                    });
                }
                
                // Handle remote player backflip animation
                if (isRemotePlayerBackflipping) {
                    const backflipElapsed = currentTime - backflipStartTime;
                    
                    // End backflip when animation completes
                    if (backflipElapsed >= backflipDuration) {
                        isRemotePlayerBackflipping = false;
                        
                        // Properly reset all animation weights
                        if (remotePlayerBackflipAction) {
                            remotePlayerBackflipAction.stop();
                            remotePlayerBackflipAction.weight = 0;
                        }
                        
                        // Reset to idle state
                        if (remotePlayerIdleAction) {
                            remotePlayerIdleAction.reset();
                            remotePlayerIdleAction.play();
                            remotePlayerIdleAction.weight = 1;
                        }
                        if (remotePlayerWalkAction) {
                            remotePlayerWalkAction.reset();
                            remotePlayerWalkAction.weight = 0;
                        }
                    }
                }
                // Only update walking/idle animations if not backflipping
                else if (remotePlayerWalkAction && remotePlayerIdleAction && !isRemotePlayerBackflipping) {
                    if (remotePlayerMoving) {
                        // Set animation direction based on movement
                        if (remotePlayerMovingBackward) {
                            remotePlayerWalkAction.timeScale = -1;
                        } else {
                            remotePlayerWalkAction.timeScale = 1;
                        }
                        
                        // Ensure backflip is completely stopped
                        if (remotePlayerBackflipAction) {
                            remotePlayerBackflipAction.stop();
                            remotePlayerBackflipAction.weight = 0;
                        }
                        
                        // Crossfade from idle to walking
                        remotePlayerWalkAction.play();
                        remotePlayerIdleAction.play();
                        
                        remotePlayerWalkAction.weight = Math.min(1, remotePlayerWalkAction.weight + delta / animationCrossfadeTime);
                        remotePlayerIdleAction.weight = 1 - remotePlayerWalkAction.weight;
                        
                    } else {
                        // Crossfade from walking to idle
                        remotePlayerWalkAction.weight = Math.max(0, remotePlayerWalkAction.weight - delta / animationCrossfadeTime);
                        remotePlayerIdleAction.weight = 1 - remotePlayerWalkAction.weight;
                        
                        if (remotePlayerWalkAction.weight === 0) {
                            remotePlayerWalkAction.stop();
                        }
                    }
                    
                    // Play footstep sounds for remote player when moving
                    if (remotePlayerMoving && audioInitialized) {
                        // Calculate step interval based on distance
                        let remoteStepInterval = 0.5;
                        
                        // Adjust step interval based on distance to player
                        const distanceToPlayer = playerPosition.distanceTo(remotePlayerPosition);
                        if (distanceToPlayer > 3) {
                            remoteStepInterval = 0.4; // Faster steps when far away
                        } else if (distanceToPlayer < 1.5) {
                            remoteStepInterval = 0.6; // Slower steps when close
                        }
                        
                        // Add slight randomness to step timing using seeded random
                        remoteStepInterval *= 0.9 + remoteFootstepRandom.random() * 0.2;
                        
                        if (currentTime - lastRemoteStepTime >= remoteStepInterval) {
                            playRemotePlayerFootstep();
                            lastRemoteStepTime = currentTime;
                        }
                    }
                }
                
                // Check for collision between players
                const playerToRemoteDistance = playerPosition.distanceTo(remotePlayerPosition);
                if (playerToRemoteDistance < playerRadius + remotePlayerRadius) {
                    // Push players apart slightly to prevent clipping
                    const pushDirection = new THREE.Vector3()
                        .subVectors(playerPosition, remotePlayerPosition)
                        .normalize();
                    
                    const pushAmount = (playerRadius + remotePlayerRadius - playerToRemoteDistance) * 0.5;
                    playerPosition.add(pushDirection.clone().multiplyScalar(pushAmount));
                    cameraContainer.position.copy(playerPosition);
                }
            }

            camera.position.copy(offset);
            camera.rotation.z = camera.rotation.z * 0.85 + targetRoll * 0.15;

            // Handle local player backflip
            if (isLocalPlayerBackflipping) {
                const backflipElapsed = currentTime - backflipStartTime;
                const backflipProgress = backflipElapsed / backflipDuration;
                
                // Rotate camera during backflip
                if (backflipProgress <= 1.0) {
                    // Rotate camera 360 degrees around X axis
                    const rotationAngle = Math.PI * 2 * backflipProgress;
                    camera.rotation.x = rotationAngle;
                }
                
                // End backflip when animation completes
                if (backflipElapsed >= backflipDuration) {
                    isLocalPlayerBackflipping = false;
                    
                    // Reset camera rotation
                    camera.rotation.x = 0;
                }
            }

            updateAudio();

            composer.render();
        }

        function getDistanceToNearestLight(position) {
            let minDistance = Infinity;
            for (const light of lights) {
                const distance = position.distanceTo(light.position);
                if (distance < minDistance) {
                    minDistance = distance;
                }
            }
            return minDistance;
        }
        
        function updateAudio() {
            if (!fluorescentBuzz.paused) {
                const distanceToLight = getDistanceToNearestLight(playerPosition);
                const maxDistance = 15;
                const minDistance = 2;
                
                let distanceVolume = 1.0;
                if (distanceToLight > minDistance) {
                    distanceVolume = Math.max(0, 1 - ((distanceToLight - minDistance) / (maxDistance - minDistance)));
                }
                
                fluorescentBuzz.volume = masterVolume * distanceVolume;
                
                // Use seeded random for audio fluctuations
                if (audioRandom.random() < 0.05) {
                    const fluctuation = 0.95 + audioRandom.random() * 0.1;
                    fluorescentBuzz.volume *= fluctuation;
                }
            } else if (gameStarted && !fluorescentBuzz.muted) {
                fluorescentBuzz.play().catch(e => console.log("Couldn't restart audio in update:", e));
            }
            
            // Update player footstep volumes
            stepSounds.forEach(sound => {
                sound.volume = masterVolume * footstepVolume;
            });
            
            // Update remote player footstep volumes
            remotePlayerStepSounds.forEach(sound => {
                // Adjust volume based on distance to player
                const distanceToPlayer = playerPosition.distanceTo(remotePlayerPosition);
                const maxDistance = 15;
                const minDistance = 1;
                
                let distanceFactor = 1.0;
                if (distanceToPlayer > minDistance) {
                    distanceFactor = Math.max(0.2, 1 - ((distanceToPlayer - minDistance) / (maxDistance - minDistance)));
                }
                
                sound.volume = masterVolume * footstepVolume * 0.4 * distanceFactor;
            });
            
            // Update positional audio
            if (positionalAudio && remotePlayerModel) {
                // Update audio position to match remote player position
                positionalAudio.position.copy(remotePlayerPosition);
                
                // Update audio rotation to match remote player rotation
                const euler = new THREE.Euler().setFromQuaternion(remotePlayerQuaternion, 'YXZ');
                positionalAudio.rotation.y = euler.y;
            }
        }

        // Multiplayer setup
        function initPeerJS() {
            peer = new Peer();
            
            peer.on('open', (id) => {
                console.log('My peer ID is: ' + id);
                myPeerIdElement.textContent = id;
                multiplayerUI.style.display = 'block';
                voiceChatControls.style.display = 'block';
            });
            
            peer.on('connection', (conn) => {
                handleConnection(conn);
                isHost = true;
            });
            
            peer.on('call', (call) => {
                handleIncomingCall(call);
            });
            
            peer.on('error', (err) => {
                console.error('PeerJS error:', err);
                connectionStatus.textContent = 'Connection error: ' + err;
            });
            
            connectButton.addEventListener('click', () => {
                const remotePeerId = remotePeerIdInput.value.trim();
                if (remotePeerId) {
                    connectionStatus.textContent = 'Connecting...';
                    const conn = peer.connect(remotePeerId);
                    handleConnection(conn);
                    isHost = false;
                }
            });
        }
        
        // Voice chat variables
        let localStream;
        let remoteStream;
        let voiceCall;
        let isVoiceChatEnabled = false;
        let isMicMuted = false;
        let remoteAudio;
        let positionalAudio;
        const voiceChatControls = document.getElementById('voice-chat-controls');
        const voiceChatStatus = document.getElementById('voice-chat-status');
        const voiceChatToggle = document.getElementById('voice-chat-toggle');
        const voiceChatMute = document.getElementById('voice-chat-mute');
        
        // Initialize voice chat
        async function initVoiceChat() {
            try {
                console.log('Initializing voice chat');
                // Request both audio input and output devices
                localStream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        echoCancellation: false,
                        noiseSuppression: false,
                        autoGainControl: true
                    }
                });
                
                isVoiceChatEnabled = true;
                voiceChatToggle.classList.add('active');
                voiceChatStatus.textContent = 'Voice Chat: Ready';
                
                // If already connected to a peer, start the call
                if (isConnected && connection) {
                    startVoiceCall();
                }
                
                console.log('Voice chat initialized successfully');
            } catch (err) {
                console.error('Error accessing microphone:', err);
                voiceChatStatus.textContent = 'Voice Chat: Microphone access denied';
            }
        }
        
        // Handle incoming voice calls
        function handleIncomingCall(call) {
            try {
                console.log('Handling incoming call');
                voiceCall = call;
                
                // Answer the call with our local stream if voice chat is enabled
                if (isVoiceChatEnabled && localStream) {
                    call.answer(localStream);
                    console.log('Answering call with local stream');
                } else {
                    call.answer(); // Answer without sending our audio
                    console.log('Answering call without local stream');
                }
                
                call.on('stream', (stream) => {
                    console.log('Received remote stream');
                    setupRemoteAudio(stream);
                });
                
                call.on('error', (error) => {
                    console.error('Call error:', error);
                    voiceChatStatus.textContent = 'Voice Chat: Call Error';
                });
                
                call.on('close', () => {
                    console.log('Call closed');
                    if (positionalAudio) {
                        positionalAudio.disconnect();
                        if (remotePlayerModel) {
                            remotePlayerModel.remove(positionalAudio);
                        }
                        positionalAudio = null;
                    }
                    voiceChatStatus.textContent = 'Voice Chat: Disconnected';
                });
            } catch (error) {
                console.error('Error in handleIncomingCall:', error);
                voiceChatStatus.textContent = 'Voice Chat: Setup Failed';
            }
        }
        
        // Start a voice call to the remote peer
        function startVoiceCall() {
            try {
                if (!isVoiceChatEnabled || !localStream || !connection) {
                    console.log('Cannot start call:', { isVoiceChatEnabled, hasLocalStream: !!localStream, hasConnection: !!connection });
                    return;
                }
                
                console.log('Starting voice call to:', connection.peer);
                voiceCall = peer.call(connection.peer, localStream);
                
                voiceCall.on('stream', (stream) => {
                    console.log('Received remote stream from outgoing call');
                    setupRemoteAudio(stream);
                });
                
                voiceCall.on('error', (error) => {
                    console.error('Call error:', error);
                    voiceChatStatus.textContent = 'Voice Chat: Call Error';
                });
                
                voiceCall.on('close', () => {
                    console.log('Call closed');
                    if (positionalAudio) {
                        positionalAudio.disconnect();
                        if (remotePlayerModel) {
                            remotePlayerModel.remove(positionalAudio);
                        }
                        positionalAudio = null;
                    }
                    voiceChatStatus.textContent = 'Voice Chat: Disconnected';
                });
            } catch (error) {
                console.error('Error in startVoiceCall:', error);
                voiceChatStatus.textContent = 'Voice Chat: Setup Failed';
            }
        }
        
        // Set up positional audio for the remote player
        function setupRemoteAudio(stream) {
            try {
                // Create a new audio element for the remote stream
                const audioElement = new Audio();
                audioElement.srcObject = stream;
                audioElement.autoplay = true;
                
                // Create positional audio if it doesn't exist
                if (!positionalAudio) {
                    positionalAudio = new THREE.PositionalAudio(audioListener);
                    positionalAudio.setRefDistance(5);
                    positionalAudio.setRolloffFactor(2);
                    positionalAudio.setDistanceModel('exponential');
                    positionalAudio.setDirectionalCone(180, 230, 0.5);
                    
                    // Create audio source from the audio element
                    const mediaElementSource = audioContext.createMediaElementSource(audioElement);
                    positionalAudio.setMediaElementSource(audioElement);
                    
                    // Add the positional audio to the remote player model
                    if (remotePlayerModel) {
                        remotePlayerModel.add(positionalAudio);
                    }
                }
                
                voiceChatStatus.textContent = 'Voice Chat: Connected';
                console.log('Remote audio setup complete');
            } catch (error) {
                console.error('Error setting up remote audio:', error);
                voiceChatStatus.textContent = 'Voice Chat: Audio Setup Failed';
            }
        }
        
        // Voice chat controls event listeners
        voiceChatToggle.addEventListener('click', () => {
            if (!isVoiceChatEnabled) {
                initVoiceChat();
            } else {
                if (localStream) {
                    localStream.getTracks().forEach(track => track.stop());
                }
                if (voiceCall) {
                    voiceCall.close();
                }
                isVoiceChatEnabled = false;
                voiceChatToggle.classList.remove('active');
                voiceChatStatus.textContent = 'Voice Chat: Disabled';
            }
        });
        
        voiceChatMute.addEventListener('click', () => {
            if (localStream) {
                const audioTrack = localStream.getAudioTracks()[0];
                if (audioTrack) {
                    isMicMuted = !isMicMuted;
                    audioTrack.enabled = !isMicMuted;
                    voiceChatMute.classList.toggle('muted', isMicMuted);
                    voiceChatMute.textContent = isMicMuted ? 'Unmute Mic' : 'Mute Mic';
                }
            }
        });
        
        // Create an audio listener for positional audio
        const audioListener = new THREE.AudioListener();
        camera.add(audioListener);
        
        // Update the handleConnection function to include voice chat
        function handleConnection(conn) {
            connection = conn;
            
            connection.on('open', () => {
                console.log('Connected to peer:', connection.peer);
                connectionStatus.textContent = 'Connected to: ' + connection.peer;
                isConnected = true;
                
                // Hide the connection form once connected
                document.getElementById('connect-form').style.display = 'none';
                
                // Show system message
                addChatMessage('Connected to another player', 'system');
                addChatMessage('The maze layout is identical for all players', 'system');
                
                // Start voice chat if enabled
                if (isVoiceChatEnabled && localStream) {
                    startVoiceCall();
                }
                
                // Load the remote player model
                loadRemotePlayerModel();
            });
            
            connection.on('data', (data) => {
                handlePeerData(data);
            });
            
            connection.on('close', () => {
                console.log('Connection closed');
                connectionStatus.textContent = 'Connection closed';
                isConnected = false;
                
                // Show system message
                addChatMessage('Disconnected from player', 'system');
                
                // Show the connection form again
                document.getElementById('connect-form').style.display = 'flex';
                
                // Remove the remote player model
                if (remotePlayerModel) {
                    scene.remove(remotePlayerModel);
                    remotePlayerModel = null;
                }
            });
            
            connection.on('error', (err) => {
                console.error('Connection error:', err);
                connectionStatus.textContent = 'Connection error: ' + err;
                
                // Show system message
                addChatMessage('Connection error: ' + err, 'system');
            });
        }
        
        function handlePeerData(data) {
            if (data.type === 'position') {
                // Update remote player position
                remotePlayerPosition.set(
                    data.position.x,
                    data.position.y,
                    data.position.z
                );
                
                // Store the quaternion data for rotation
                remotePlayerQuaternion.set(
                    data.quaternion.x,
                    data.quaternion.y,
                    data.quaternion.z,
                    data.quaternion.w
                );
                
                remotePlayerMoving = data.isMoving;
                remotePlayerMovingBackward = data.isMovingBackward; // Store backward movement state
            } else if (data.type === 'chat') {
                addChatMessage(data.message, 'other');
            } else if (data.type === 'backflip') {
                // Trigger backflip animation for remote player
                if (remotePlayerBackflipAction && !isRemotePlayerBackflipping) {
                    isRemotePlayerBackflipping = true;
                    backflipStartTime = clock.getElapsedTime();
                    
                    // Reset weights of other animations
                    if (remotePlayerIdleAction) remotePlayerIdleAction.weight = 0;
                    if (remotePlayerWalkAction) remotePlayerWalkAction.weight = 0;
                    
                    // Set backflip animation weight to 1
                    remotePlayerBackflipAction.reset();
                    remotePlayerBackflipAction.weight = 1;
                    remotePlayerBackflipAction.play();
                    
                    // Add chat message
                    addChatMessage('Other player is doing a backflip!', 'system');
                }
            }
        }
        
        function loadRemotePlayerModel() {
            // Set up DRACO loader for decompression
            const dracoLoader = new DRACOLoader();
            dracoLoader.setDecoderPath('https://www.gstatic.com/draco/versioned/decoders/1.5.6/');
            
            // Set up GLTF loader with DRACO loader
            const loader = new GLTFLoader();
            loader.setDRACOLoader(dracoLoader);
            
            loader.load(
                'character.glb',
                (gltf) => {
                    console.log("GLTF model loaded successfully:", gltf);
                    createRemotePlayerFromGLTF(gltf);
                },
                (xhr) => {
                    console.log((xhr.loaded / xhr.total * 100) + '% loaded remote player model');
                },
                (error) => {
                    console.error('Error loading GLTF model:', error);
                    addChatMessage('Error loading character model, using fallback', 'system');
                    createFallbackRemotePlayer();
                }
            );
        }
        
        function createRemotePlayerFromGLTF(gltf) {
            // Create a container for the model to handle rotation correctly
            const modelContainer = new THREE.Group();
            
            // Get the model from the GLTF scene
            const model = gltf.scene;
            
            // Add the model to the container with a 180-degree rotation
            // This ensures the model faces forward relative to the camera direction
            model.rotation.y = Math.PI;
            modelContainer.add(model);
            
            // Position the container at the initial position
            remotePlayerPosition.set(startingRoomWidth / 2 - 1, 0, startingRoomDepth / 2 - 1);
            remotePlayerLastPosition.copy(remotePlayerPosition);
            modelContainer.position.copy(remotePlayerPosition);
            
            // Add the container to the scene
            scene.add(modelContainer);
            
            // Use the container as our remote player model
            remotePlayerModel = modelContainer;
            
            // Adjust scale to match desired height (around 1.7-1.8 units)
            const targetHeight = 3.0;
            const box = new THREE.Box3().setFromObject(model);
            const size = box.getSize(new THREE.Vector3());
            
            if (size.y > 0) {
                const scale = targetHeight / size.y;
                model.scale.set(scale, scale, scale);
                remotePlayerYOffset = 0;
            }
            
            // Setup animation mixer
            remotePlayerMixer = new THREE.AnimationMixer(model);
            
            // Find the idle and walking animations
            let idleAnimation = null;
            let walkingAnimation = null;
            let backflipAnimation = null;

            if (gltf.animations && gltf.animations.length > 0) {
                // Find animations by name
                gltf.animations.forEach(clip => {
                    if (clip.name.toLowerCase().includes('idle')) {
                        idleAnimation = clip;
                    } else if (clip.name.toLowerCase().includes('walk')) {
                        walkingAnimation = clip;
                    } else if (clip.name.toLowerCase().includes('backflip')) {
                        backflipAnimation = clip;
                    }
                });
                
                // If we found the animations, set them up
                if (idleAnimation) {
                    remotePlayerIdleAction = remotePlayerMixer.clipAction(idleAnimation);
                    remotePlayerIdleAction.setLoop(THREE.LoopRepeat);
                    remotePlayerIdleAction.play();
                    remotePlayerIdleAction.weight = 1.0;
                }
                
                if (walkingAnimation) {
                    remotePlayerWalkAction = remotePlayerMixer.clipAction(walkingAnimation);
                    remotePlayerWalkAction.setLoop(THREE.LoopRepeat);
                    remotePlayerWalkAction.timeScale = 1;
                    remotePlayerWalkAction.play();
                    remotePlayerWalkAction.weight = 0.0;
                }
                
                if (backflipAnimation) {
                    remotePlayerBackflipAction = remotePlayerMixer.clipAction(backflipAnimation);
                    remotePlayerBackflipAction.setLoop(THREE.LoopOnce);
                    remotePlayerBackflipAction.clampWhenFinished = true;
                    remotePlayerBackflipAction.timeScale = 1;
                    remotePlayerBackflipAction.weight = 0.0;
                    backflipDuration = backflipAnimation.duration;
                }
            }
            
            // Compute bounding box and apply materials
            model.traverse((child) => {
                if (child.isMesh) {
                    child.geometry.computeBoundingBox();
                    if (child.material) {
                        child.material.needsUpdate = true;
                    }
                }
            });
            
            addChatMessage('Remote player model loaded', 'system');
        }
        
        function createFallbackRemotePlayer() {
            // Create a simple humanoid shape as fallback
            const modelContainer = new THREE.Group();
            
            // Create a body
            const bodyGeometry = new THREE.CapsuleGeometry(0.3, 1.0, 4, 8);
            const bodyMaterial = new THREE.MeshBasicMaterial({ color: 0x66a8e5 });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.set(0, 0.8, 0);
            modelContainer.add(body);
            
            // Create a head
            const headGeometry = new THREE.SphereGeometry(0.25, 16, 16);
            const headMaterial = new THREE.MeshBasicMaterial({ color: 0x66a8e5 });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.set(0, 1.7, 0);
            modelContainer.add(head);
            
            // Position the container at the initial position
            remotePlayerPosition.set(startingRoomWidth / 2 - 1, 0, startingRoomDepth / 2 - 1);
            remotePlayerLastPosition.copy(remotePlayerPosition);
            modelContainer.position.copy(remotePlayerPosition);
            
            // Add the container to the scene
            scene.add(modelContainer);
            
            // Use the container as our remote player model
            remotePlayerModel = modelContainer;
            
            addChatMessage('Using fallback player model', 'system');
        }

        // Initialize game
        function initGame() {
            gameStarted = true;
            loadingScreen.style.opacity = '0';
            setTimeout(() => {
                loadingScreen.style.display = 'none';
                
                // On desktop, lock pointer controls
                if (!isMobile) {
                    controls.lock();
                } else {
                    // For mobile, show the game UI right away
                    document.getElementById('game-ui').style.display = 'block';
                    document.getElementById('fps-counter').style.display = 'block';
                    document.getElementById('audio-controls').style.display = 'block';
                    
                    // Show mobile controls info
                    document.getElementById('mobile-controls-info').style.display = 'block';
                    document.getElementById('desktop-controls').style.display = 'none';
                }
                
                initAudio();
                initPeerJS(); // Initialize PeerJS when the game starts
                initChat(); // Initialize chat system
            }, 1000);
            
            clock.start();
            animate();
        }

        // Start button event listener
        startButton.addEventListener('click', initGame);

        // Handle local player backflip
        if (isLocalPlayerBackflipping) {
            const backflipElapsed = currentTime - backflipStartTime;
            const backflipProgress = backflipElapsed / backflipDuration;
            
            // Rotate camera during backflip
            if (backflipProgress <= 1.0) {
                // Rotate camera 360 degrees around X axis
                const rotationAngle = Math.PI * 2 * backflipProgress;
                camera.rotation.x = rotationAngle;
            }
            
            // End backflip when animation completes
            if (backflipElapsed >= backflipDuration) {
                isLocalPlayerBackflipping = false;
                
                // Reset camera rotation
                camera.rotation.x = 0;
            }
        }
    </script>
</body>
</html>