<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multiplayer Backrooms Game</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        
        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 999;
            color: #e9e566;
            font-family: monospace;
            transition: opacity 1s;
        }
        
        #loading-bar-container {
            width: 50%;
            height: 30px;
            background-color: #222;
            border: 2px solid #e9e566;
            margin-top: 20px;
            position: relative;
        }
        
        #loading-bar {
            height: 100%;
            width:0%;
            background-color: #e9e566;
            transition: width 0.3s;
        }
        
        #loading-text {
            font-size: 24px;
            margin-bottom: 10px;
        }
        
        #loading-progress {
            position: absolute;
            width: 100%;
            text-align: center;
            top: 5px;
            font-size: 16px;
        }
        
        #start-button {
            margin-top: 30px;
            padding: 10px 20px;
            background-color: #e9e566;
            color: #000;
            border: none;
            font-family: monospace;
            font-size: 18px;
            cursor: pointer;
            display: none;
        }
        
        #start-button:hover {
            background-color: #fff;
        }
        
        #game-ui {
            position: fixed;
            bottom: 20px;
            left: 20px;
            color: #e9e566;
            font-family: monospace;
            font-size: 14px;
            z-index: 10;
            text-shadow: 1px 1px 2px #000;
        }
        
        #fps-counter {
            position: fixed;
            top: 10px;
            right: 10px;
            color: #e9e566;
            font-family: monospace;
            font-size: 14px;
            z-index: 10;
            text-shadow: 1px 1px 2px #000;
            background-color: rgba(0, 0, 0, 0.3);
            padding: 5px 10px;
            border-radius: 3px;
        }
        
        #audio-controls {
            position: fixed;
            bottom: 50px;
            left: 20px;
            color: #e9e566;
            font-family: monospace;
            font-size: 14px;
            z-index: 10;
            text-shadow: 1px 1px 2px #000;
            display: none;
        }
        
        #volume-slider {
            width: 100px;
            margin-left: 10px;
            vertical-align: middle;
        }
        
        /* Multiplayer UI */
        #multiplayer-ui {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #e9e566;
            font-family: monospace;
            font-size: 14px;
            z-index: 10;
            text-shadow: 1px 1px 2px #000;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            display: none;
        }
        
        #peer-id {
            font-weight: bold;
            margin-bottom: 10px;
        }
        
        #connect-form {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        #connect-form input {
            padding: 5px;
            background-color: #333;
            border: 1px solid #e9e566;
            color: #e9e566;
            font-family: monospace;
        }
        
        #connect-form button {
            padding: 5px 10px;
            background-color: #e9e566;
            color: #000;
            border: none;
            font-family: monospace;
            cursor: pointer;
            margin-top: 5px;
        }
        
        #connect-form button:hover {
            background-color: #fff;
        }
        
        #connection-status {
            margin-top: 10px;
            font-style: italic;
        }
        
        /* Chat UI */
        #chat-container {
            position: fixed;
            bottom: 100px;
            left: 20px;
            width: 300px;
            color: #e9e566;
            font-family: monospace;
            font-size: 14px;
            z-index: 10;
            text-shadow: 1px 1px 2px #000;
            display: none;
        }
        
        #chat-messages {
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px 5px 0 0;
            max-height: 150px;
            overflow-y: auto;
            margin-bottom: 5px;
        }
        
        #chat-form {
            display: flex;
            gap: 5px;
        }
        
        #chat-input {
            flex-grow: 1;
            padding: 5px;
            background-color: rgba(0, 0, 0, 0.5);
            border: 1px solid #e9e566;
            color: #e9e566;
            font-family: monospace;
            border-radius: 0 0 0 5px;
        }
        
        #chat-send {
            padding: 5px 10px;
            background-color: #e9e566;
            color: #000;
            border: none;
            font-family: monospace;
            cursor: pointer;
            border-radius: 0 0 5px 0;
        }
        
        #chat-send:hover {
            background-color: #fff;
        }
        
        .chat-message {
            margin-bottom: 5px;
            word-wrap: break-word;
        }
        
        .chat-message.self {
            color: #a8e566;
        }
        
        .chat-message.other {
            color: #e5c066;
        }
        
        .chat-message.system {
            color: #e566a8;
            font-style: italic;
        }
    </style>
</head>
<body>
    <div id="loading-screen">
        <div id="loading-text">FALLING INTO THE BACKROOMS</div>
        <div id="loading-bar-container">
            <div id="loading-bar"></div>
            <div id="loading-progress">0%</div>
        </div>
        <button id="start-button">ENTER</button>
    </div>
    
    <div id="game-ui" style="display: none;">
        <div>WASD: Move | SHIFT: Run | CTRL: Crouch | F: Backflip | CLICK: Look | T: Chat | V: Toggle Direction Helper</div>
    </div>
    
    <div id="fps-counter" style="display: none;">FPS: 0</div>
    
    <div id="audio-controls" style="display: none;">
        <span>Sound: </span>
        <input type="range" id="volume-slider" min="0" max="100" value="70">
        <span id="volume-value">70%</span>
    </div>
    
    <!-- Multiplayer UI -->
    <div id="multiplayer-ui">
        <div id="peer-id">Your ID: <span id="my-peer-id">Connecting...</span></div>
        <div id="connect-form">
            <input type="text" id="remote-peer-id" placeholder="Enter peer ID to connect">
            <button id="connect-button">Connect</button>
        </div>
        <div id="connection-status">Not connected</div>
    </div>
    
    <!-- Chat UI -->
    <div id="chat-container" style="display: none;">
        <div id="chat-messages"></div>
        <form id="chat-form">
            <input type="text" id="chat-input" placeholder="Type a message..." autocomplete="off">
            <button type="submit" id="chat-send">Send</button>
        </form>
    </div>
    
    <audio id="fluorescent-buzz" loop preload="auto">
        <source src="fluorescent.mp3" type="audio/mpeg">
    </audio>
    
    <!-- PeerJS Library -->
    <script src="https://unpkg.com/peerjs@1.5.4/dist/peerjs.min.js"></script>
    
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.174.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.174.0/examples/jsm/"
        }
    }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
        import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';

        const loadingScreen = document.getElementById('loading-screen');
        const loadingBar = document.getElementById('loading-bar');
        const loadingProgressElement = document.getElementById('loading-progress');
        const startButton = document.getElementById('start-button');
        const fpsCounter = document.getElementById('fps-counter');
        const multiplayerUI = document.getElementById('multiplayer-ui');
        const myPeerIdElement = document.getElementById('my-peer-id');
        const remotePeerIdInput = document.getElementById('remote-peer-id');
        const connectButton = document.getElementById('connect-button');
        const connectionStatus = document.getElementById('connection-status');
        const chatContainer = document.getElementById('chat-container');
        const chatMessages = document.getElementById('chat-messages');
        const chatForm = document.getElementById('chat-form');
        const chatInput = document.getElementById('chat-input');
        
        let gameStarted = false;
        let audioInitialized = false;
        let isChatting = false;
        
        // Multiplayer variables
        let peer;
        let connection;
        let isHost = false;
        let isConnected = false;
        let remotePlayerModel;
        let remotePlayerPosition = new THREE.Vector3();
        let remotePlayerRotation = new THREE.Euler();
        let remotePlayerQuaternion = new THREE.Quaternion(); // Add quaternion for better rotation handling
        let remotePlayerMoving = false;
        let remotePlayerMovingBackward = false; // Add this new variable
        let remotePlayerLastPosition = new THREE.Vector3();
        let remotePlayerMixer;
        let remotePlayerWalkAction;
        let remotePlayerIdleAction;
        let remotePlayerBackflipAction; // Add new variable for backflip animation
        let isLocalPlayerBackflipping = false; // Flag to track if local player is backflipping
        let isRemotePlayerBackflipping = false; // Flag to track if remote player is backflipping
        let backflipStartTime = 0; // Track when backflip started
        let backflipDuration = 1.0; // Duration of backflip animation in seconds
        let lastDataSentTime = 0;
        const DATA_SEND_INTERVAL = 0.05; // Send data 20 times per second
        let directionHelper; // Debug helper to show remote player direction
        let showDirectionHelper = true; // Toggle for direction helper
        const animationCrossfadeTime = 0.3; // Time in seconds for animation crossfade
        
        const VHSShader = {
            uniforms: {
                "tDiffuse": { value: null },
                "time": { value: 0.0 },
                "distortion": { value: 0.8 },
                "noise": { value: 0.5 },
                "lineSpeed": { value: 0.6 }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform sampler2D tDiffuse;
                uniform float time;
                uniform float distortion;
                uniform float noise;
                uniform float lineSpeed;
                varying vec2 vUv;

                float random(vec2 st) {
                    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
                }

                void main() {
                    vec2 uv = vUv;
                    float verticalDisplace = sin(uv.y * 10.0 + time * lineSpeed) * 0.0008;
                    uv.x += verticalDisplace * distortion;

                    vec4 baseColor = texture2D(tDiffuse, uv);
                    float r = texture2D(tDiffuse, uv + vec2(0.003, 0.0) * distortion).r;
                    float g = baseColor.g;
                    float b = texture2D(tDiffuse, uv - vec2(0.003, 0.0) * distortion).b;

                    float noiseValue = random(uv + vec2(time * 0.1));
                    vec4 color = vec4(r, g, b, 1.0);
                    color.rgb = mix(color.rgb, vec3(noiseValue), noise * 0.08);

                    float scanline = sin(uv.y * 900.0 + time * 5.0) * 0.015;
                    color.rgb += scanline;

                    float glitchTime = floor(time * 0.8);
                    float glitchPos = random(vec2(glitchTime));
                    if (random(vec2(glitchTime * 0.1)) > 0.99 && 
                        abs(uv.y - glitchPos) < 0.03) {
                        uv.x += (random(vec2(glitchTime)) * 2.0 - 1.0) * 0.03;
                        color = texture2D(tDiffuse, uv);
                    }

                    gl_FragColor = color;
                }
            `
        };

        class UnionFind {
            constructor(size) {
                this.parent = new Array(size);
                this.rank = new Array(size);
                for (let i = 0; i < size; i++) {
                    this.parent[i] = i;
                    this.rank[i] = 0;
                }
            }
            find(x) {
                if (this.parent[x] !== x) {
                    this.parent[x] = this.find(this.parent[x]);
                }
                return this.parent[x];
            }
            union(x, y) {
                let rootX = this.find(x);
                let rootY = this.find(y);
                if (rootX === rootY) return false;
                if (this.rank[rootX] < this.rank[rootY]) {
                    this.parent[rootX] = rootY;
                } else if (this.rank[rootX] > this.rank[rootY]) {
                    this.parent[rootY] = rootX;
                } else {
                    this.parent[rootY] = rootX;
                    this.rank[rootX]++;
                }
                return true;
            }
        }

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.0;
        document.body.appendChild(renderer.domElement);

        const composer = new EffectComposer(renderer);
        const renderPass = new RenderPass(scene, camera);
        composer.addPass(renderPass);

        const vhsPass = new ShaderPass(VHSShader);
        composer.addPass(vhsPass);

        const cameraContainer = new THREE.Object3D();
        scene.add(cameraContainer);
        cameraContainer.add(camera);
        camera.position.set(0, 0, 0);

        const controls = new PointerLockControls(cameraContainer, renderer.domElement);
        
        document.addEventListener('click', () => {
            if (gameStarted) {
                controls.lock();
            }
        });
        
        controls.addEventListener('lock', () => {
            if (gameStarted && uiVisible) {
                document.getElementById('game-ui').style.display = 'block';
            }
        });
        
        controls.addEventListener('unlock', () => {
            if (gameStarted && uiVisible) {
                document.getElementById('game-ui').style.display = 'block';
            }
        });

        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let isRunning = false;
        let isCrouching = false;
        let uiVisible = false;

        const fluorescentBuzz = document.getElementById('fluorescent-buzz');
        
        const stepSounds = [];
        const STEP_COUNT = 12;
        
        for (let i = 1; i <= STEP_COUNT; i++) {
            const stepSound = new Audio(`steps/step${i}.mp3`);
            stepSound.preload = 'auto';
            stepSounds.push(stepSound);
        }
        
        // Remote player footstep sounds
        const remotePlayerStepSounds = [];
        for (let i = 1; i <= STEP_COUNT; i++) {
            const remoteStepSound = new Audio(`steps/step${i}.mp3`);
            remoteStepSound.preload = 'auto';
            // Make remote player steps slightly quieter than player steps
            remoteStepSound.volume = 0.4;
            remotePlayerStepSounds.push(remoteStepSound);
        }
        
        const volumeSlider = document.getElementById('volume-slider');
        const volumeValue = document.getElementById('volume-value');
        let masterVolume = 0.7;
        let footstepVolume = 0.5;
        let lastStepTime = 0;
        let lastStepIndex = -1;
        let lastRemoteStepTime = 0;
        let lastRemoteStepIndex = -1;
        
        fluorescentBuzz.volume = masterVolume;
        stepSounds.forEach(sound => {
            sound.volume = masterVolume * footstepVolume;
        });
        remotePlayerStepSounds.forEach(sound => {
            sound.volume = masterVolume * footstepVolume * 0.4; // Remote player steps are quieter
        });
        
        let audioContext;
        
        function initAudio() {
            if (audioInitialized) return;
            
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
            
            fluorescentBuzz.play().then(() => {
                console.log("Audio playback started successfully");
                audioInitialized = true;
            }).catch(error => {
                console.log("Audio playback failed:", error);
            });
        }
        
        function playFootstep() {
            if (!audioInitialized) return;
            
            const isAnyStepPlaying = stepSounds.some(sound => !sound.paused && sound.currentTime < sound.duration - 0.05);
            if (isAnyStepPlaying) return;
            
            let stepIndex;
            do {
                stepIndex = Math.floor(footstepRandom.random() * stepSounds.length);
            } while (stepIndex === lastStepIndex && stepSounds.length > 1);
            
            lastStepIndex = stepIndex;
            
            const stepSound = stepSounds[stepIndex];
            stepSound.currentTime = 0;
            stepSound.volume = masterVolume * footstepVolume;
            
            stepSound.play().catch(e => {
                console.log("Couldn't play step sound:", e);
            });
        }
        
        function playRemotePlayerFootstep() {
            if (!audioInitialized) return;
            
            const isAnyRemoteStepPlaying = remotePlayerStepSounds.some(sound => !sound.paused && sound.currentTime < sound.duration - 0.05);
            if (isAnyRemoteStepPlaying) return;
            
            let stepIndex;
            do {
                stepIndex = Math.floor(remoteFootstepRandom.random() * remotePlayerStepSounds.length);
            } while (stepIndex === lastRemoteStepIndex && remotePlayerStepSounds.length > 1);
            
            lastRemoteStepIndex = stepIndex;
            
            const stepSound = remotePlayerStepSounds[stepIndex];
            stepSound.currentTime = 0;
            stepSound.volume = masterVolume * footstepVolume * 0.4; // Quieter than player footsteps
            
            // Add slight pitch variation to differentiate from player footsteps
            const pitchVariation = 0.9 + remoteFootstepRandom.random() * 0.2; // Between 0.9 and 1.1
            stepSound.playbackRate = pitchVariation;
            
            stepSound.play().catch(e => {
                console.log("Couldn't play remote player step sound:", e);
            });
        }
        
        document.addEventListener('click', initAudio, { once: false });
        document.addEventListener('keydown', initAudio, { once: false });
        document.addEventListener('touchstart', initAudio, { once: false });
        
        volumeSlider.addEventListener('input', () => {
            masterVolume = volumeSlider.value / 100;
            volumeValue.textContent = `${volumeSlider.value}%`;
            fluorescentBuzz.volume = masterVolume;
            stepSounds.forEach(sound => {
                sound.volume = masterVolume * footstepVolume;
            });
            remotePlayerStepSounds.forEach(sound => {
                sound.volume = masterVolume * footstepVolume * 0.4;
            });
        });
        
        document.addEventListener('keydown', (event) => {
            if (!gameStarted) return;
            
            // If in chat mode, don't process movement keys
            if (isChatting) return;
            
            switch (event.code) {
                case 'KeyW': moveForward = true; break;
                case 'KeyS': moveBackward = true; break;
                case 'KeyA': moveLeft = true; break;
                case 'KeyD': moveRight = true; break;
                case 'ShiftLeft': 
                case 'ShiftRight': 
                    isRunning = true; 
                    break;
                case 'ControlLeft':
                case 'ControlRight':
                    if (!isCrouching) {
                        isCrouching = true;
                        camera.position.y -= 0.5;
                        playerPosition.y -= 0.5;
                    }
                    break;
                case 'KeyF':
                    // Trigger backflip animation if not already backflipping
                    if (!isLocalPlayerBackflipping && remotePlayerBackflipAction) {
                        isLocalPlayerBackflipping = true;
                        backflipStartTime = clock.getElapsedTime();
                        
                        // Play backflip animation on local player's model
                        if (remotePlayerBackflipAction) {
                            // Reset weights of other animations
                            if (remotePlayerIdleAction) remotePlayerIdleAction.weight = 0;
                            if (remotePlayerWalkAction) remotePlayerWalkAction.weight = 0;
                            
                            // Set backflip animation weight to 1
                            remotePlayerBackflipAction.reset();
                            remotePlayerBackflipAction.weight = 1;
                            remotePlayerBackflipAction.play();
                        }
                        
                        // Send backflip event to other player if connected
                        if (isConnected && connection) {
                            connection.send({
                                type: 'backflip',
                                startTime: backflipStartTime
                            });
                            
                            // Add chat message
                            addChatMessage('You did a backflip!', 'system');
                        }
                    }
                    break;
                case 'KeyH':
                    uiVisible = !uiVisible;
                    document.getElementById('game-ui').style.display = uiVisible ? 'block' : 'none';
                    document.getElementById('fps-counter').style.display = uiVisible ? 'block' : 'none';
                    document.getElementById('audio-controls').style.display = uiVisible ? 'block' : 'none';
                    break;
                case 'KeyM':
                    fluorescentBuzz.muted = !fluorescentBuzz.muted;
                    break;
                case 'KeyR':
                    if (fluorescentBuzz.paused) {
                        fluorescentBuzz.play().catch(e => console.log("Couldn't restart audio:", e));
                    }
                    break;
                case 'KeyT':
                    // Enter chat mode
                    if (isConnected) {
                        isChatting = true;
                        controls.unlock();
                        chatContainer.style.display = 'block';
                        chatInput.focus();
                    } else {
                        addChatMessage('Not connected to another player', 'system');
                    }
                    break;
                case 'KeyV':
                    // Toggle direction helper visibility
                    if (directionHelper) {
                        showDirectionHelper = !showDirectionHelper;
                        directionHelper.visible = showDirectionHelper;
                        addChatMessage(`Direction helper ${showDirectionHelper ? 'shown' : 'hidden'}`, 'system');
                    }
                    break;
            }
        });
        
        document.addEventListener('keyup', (event) => {
            if (!gameStarted) return;
            
            switch (event.code) {
                case 'KeyW': moveForward = false; break;
                case 'KeyS': moveBackward = false; break;
                case 'KeyA': moveLeft = false; break;
                case 'KeyD': moveRight = false; break;
                case 'ShiftLeft': 
                case 'ShiftRight': 
                    isRunning = false; 
                    break;
                case 'ControlLeft':
                case 'ControlRight':
                    if (isCrouching) {
                        isCrouching = false;
                        camera.position.y += 0.5;
                        playerPosition.y += 0.5;
                    }
                    break;
            }
        });

        const clock = new THREE.Clock();
        const walls = [];

        const N = 10;
        const M = 10;
        const roomSize = 6;

        // Create a seeded random number generator for consistent maze generation
        class SeededRandom {
            constructor(seed = 12345) {
                this.seed = seed;
            }
            
            // Simple random function that uses the seed
            random() {
                const x = Math.sin(this.seed++) * 10000;
                return x - Math.floor(x);
            }
        }
        
        // Create fixed-seed random generators for different purposes
        const mazeRandom = new SeededRandom(12345);
        const audioRandom = new SeededRandom(24680);
        const footstepRandom = new SeededRandom(13579);
        const remoteFootstepRandom = new SeededRandom(97531);

        const horizontalWalls = Array.from({ length: N - 1 }, () => Array(M).fill(true));
        const verticalWalls = Array.from({ length: N }, () => Array(M - 1).fill(true));

        const wallList = [];
        for (let k = 0; k < N - 1; k++) {
            for (let j = 0; j < M; j++) {
                const roomA = k * M + j;
                const roomB = (k + 1) * M + j;
                wallList.push({ type: 'horizontal', k, j, rooms: [roomA, roomB] });
            }
        }
        for (let i = 0; i < N; i++) {
            for (let l = 0; l < M - 1; l++) {
                const roomA = i * M + l;
                const roomB = i * M + (l + 1);
                wallList.push({ type: 'vertical', i, l, rooms: [roomA, roomB] });
            }
        }

        // Use the seeded random for shuffling the wall list
        for (let i = wallList.length - 1; i > 0; i--) {
            const j = Math.floor(mazeRandom.random() * (i + 1));
            [wallList[i], wallList[j]] = [wallList[j], wallList[i]];
        }

        const uf = new UnionFind(N * M);
        let components = N * M;
        let index = 0;
        while (components > 1 && index < wallList.length) {
            const wall = wallList[index];
            const [roomA, roomB] = wall.rooms;
            if (uf.union(roomA, roomB)) {
                if (wall.type === 'horizontal') {
                    horizontalWalls[wall.k][wall.j] = false;
                } else {
                    verticalWalls[wall.i][wall.l] = false;
                }
                components--;
            }
            index++;
        }

        // Use seeded random for additional wall removal
        for (let k = 0; k < N - 1; k++) {
            for (let j = 0; j < M; j++) {
                if (horizontalWalls[k][j] && mazeRandom.random() < 0.08) {
                    horizontalWalls[k][j] = false;
                }
            }
        }
        for (let i = 0; i < N; i++) {
            for (let l = 0; l < M - 1; l++) {
                if (verticalWalls[i][l] && mazeRandom.random() < 0.08) {
                    verticalWalls[i][l] = false;
                }
            }
        }

        const createWallpaperTexture = () => {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const size = 512;
            canvas.width = size;
            canvas.height = size;

            ctx.fillStyle = '#e9e566';
            ctx.fillRect(0, 0, size, size);

            const stripeWidth = size / 20;
            ctx.fillStyle = '#d6d259';
            for (let i = 0; i < 20; i += 2) {
                ctx.fillRect(i * stripeWidth, 0, stripeWidth, size);
            }

            ctx.fillStyle = '#c8c44d';
            const thinLineWidth = stripeWidth * 0.2;
            for (let i = 1; i < 20; i += 2) {
                const xPos = i * stripeWidth + (stripeWidth - thinLineWidth) / 2;
                ctx.fillRect(xPos, 0, thinLineWidth, size);
            }

            const arrowHeight = size / 25;
            const arrowWidth = stripeWidth * 0.8;
            ctx.fillStyle = '#c8c44d';

            for (let y = 0; y < size; y += arrowHeight * 2) {
                for (let x = stripeWidth / 2; x < size; x += stripeWidth * 2) {
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(x + arrowWidth / 2, y + arrowHeight);
                    ctx.lineTo(x, y + arrowHeight * 2);
                    ctx.lineTo(x - arrowWidth / 2, y + arrowHeight);
                    ctx.closePath();
                    ctx.fill();
                }
            }

            return new THREE.CanvasTexture(canvas);
        };

        const createCeilingTexture = () => {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const size = 512;
            canvas.width = size;
            canvas.height = size;

            ctx.fillStyle = '#fffacd';
            ctx.fillRect(0, 0, size, size);

            ctx.strokeStyle = '#d6d259';
            ctx.lineWidth = 2;
            const gridCount = 8;
            const gridSize = size / gridCount;

            for (let i = 0; i <= gridCount; i++) {
                ctx.beginPath();
                ctx.moveTo(0, i * gridSize);
                ctx.lineTo(size, i * gridSize);
                ctx.stroke();
            }

            for (let i = 0; i <= gridCount; i++) {
                ctx.beginPath();
                ctx.moveTo(i * gridSize, 0);
                ctx.lineTo(i * gridSize, size);
                ctx.stroke();
            }

            return new THREE.CanvasTexture(canvas);
        };

        const createNormalMap = () => {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const size = 512;
            canvas.width = size;
            canvas.height = size;

            ctx.fillStyle = '#8080ff';
            ctx.fillRect(0, 0, size, size);

            // Use seeded random for normal map generation
            const textureRandom = new SeededRandom(54321);

            for (let i = 0; i < 200; i++) {
                const x = textureRandom.random() * size;
                const y = textureRandom.random() * size;
                const radius = 2 + textureRandom.random() * 5;

                const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
                gradient.addColorStop(0, '#7878ff');
                gradient.addColorStop(1, '#8080ff');

                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
            }

            return new THREE.CanvasTexture(canvas);
        };

        const createFloorTexture = () => {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const size = 512;
            canvas.width = size;
            canvas.height = size;

            ctx.fillStyle = '#a68f3e';
            ctx.fillRect(0, 0, size, size);

            // Use seeded random for floor texture generation
            const textureRandom = new SeededRandom(67890);

            const imageData = ctx.getImageData(0, 0, size, size);
            const data = imageData.data;
            for (let i = 0; i < data.length; i += 4) {
                const noise = (textureRandom.random() - 0.5) * 10;
                data[i]   += noise;
                data[i+1] += noise;
                data[i+2] += noise;
            }
            ctx.putImageData(imageData, 0, 0);

            return new THREE.CanvasTexture(canvas);
        };

        const createFloorNormalMap = () => {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const size = 512;
            canvas.width = size;
            canvas.height = size;

            ctx.fillStyle = '#8080ff';
            ctx.fillRect(0, 0, size, size);

            // Use seeded random for floor normal map generation
            const textureRandom = new SeededRandom(98765);

            for (let i = 0; i < 200; i++) {
                const x = textureRandom.random() * size;
                const y = textureRandom.random() * size;
                const radius = 2 + textureRandom.random() * 8;

                const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
                gradient.addColorStop(0, '#7878ff');
                gradient.addColorStop(1, '#8080ff');

                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
            }

            return new THREE.CanvasTexture(canvas);
        };

        const wallTexture = createWallpaperTexture();
        wallTexture.wrapS = THREE.RepeatWrapping;
        wallTexture.wrapT = THREE.RepeatWrapping;
        wallTexture.repeat.set(2, 1);

        const ceilingTexture = createCeilingTexture();
        ceilingTexture.wrapS = THREE.RepeatWrapping;
        ceilingTexture.wrapT = THREE.RepeatWrapping;
        ceilingTexture.repeat.set(M, N);

        const normalMap = createNormalMap();

        const floorTexture = createFloorTexture();
        floorTexture.wrapS = THREE.RepeatWrapping;
        floorTexture.wrapT = THREE.RepeatWrapping;
        floorTexture.repeat.set(N, N);

        const floorNormalMap = createFloorNormalMap();
        floorNormalMap.wrapS = THREE.RepeatWrapping;
        floorNormalMap.wrapT = THREE.RepeatWrapping;
        floorNormalMap.repeat.set(N, N);

        const wallMaterial = new THREE.MeshStandardMaterial({
            map: wallTexture,
            normalMap: normalMap,
            normalScale: new THREE.Vector2(0.5, 0.5),
            roughness: 0.7,
            metalness: 0.1,
            envMapIntensity: 1.0,
            color: 0xffffff
        });

        const startingRoomWidth = 10;
        const startingRoomDepth = 10;
        const hallwayWidth = 4;
        const hallwayLength = 100;

        function createStartingRoom() {
            const roomWalls = [
                new THREE.Mesh(
                    new THREE.BoxGeometry(0.3, 5, startingRoomDepth),
                    wallMaterial
                ),
                new THREE.Mesh(
                    new THREE.BoxGeometry(0.3, 5, startingRoomDepth),
                    wallMaterial
                ),
                new THREE.Mesh(
                    new THREE.BoxGeometry(startingRoomWidth, 5, 0.3),
                    wallMaterial
                ),
                new THREE.Mesh(
                    new THREE.BoxGeometry((startingRoomWidth - hallwayWidth) / 2, 5, 0.3),
                    wallMaterial
                ),
                new THREE.Mesh(
                    new THREE.BoxGeometry((startingRoomWidth - hallwayWidth) / 2, 5, 0.3),
                    wallMaterial
                )
            ];

            roomWalls[0].position.set(0, 2.5, startingRoomDepth / 2);
            roomWalls[1].position.set(startingRoomWidth, 2.5, startingRoomDepth / 2);
            roomWalls[2].position.set(startingRoomWidth / 2, 2.5, 0);
            roomWalls[3].position.set((startingRoomWidth - hallwayWidth) / 4, 2.5, startingRoomDepth);
            roomWalls[4].position.set(startingRoomWidth - (startingRoomWidth - hallwayWidth) / 4, 2.5, startingRoomDepth);

            roomWalls.forEach(wall => {
                scene.add(wall);
                walls.push(wall);
            });

            return roomWalls;
        }

        function createHallway() {
            const hallwayWalls = [
                new THREE.Mesh(
                    new THREE.BoxGeometry(0.3, 5, hallwayLength),
                    wallMaterial
                ),
                new THREE.Mesh(
                    new THREE.BoxGeometry(0.3, 5, hallwayLength),
                    wallMaterial
                )
            ];

            const hallwayStartZ = startingRoomDepth;
            const hallwayStartX = (startingRoomWidth - hallwayWidth) / 2;
            
            hallwayWalls[0].position.set(hallwayStartX, 2.5, hallwayStartZ + hallwayLength / 2);
            hallwayWalls[1].position.set(hallwayStartX + hallwayWidth, 2.5, hallwayStartZ + hallwayLength / 2);

            hallwayWalls.forEach(wall => {
                scene.add(wall);
                walls.push(wall);
            });

            return hallwayWalls;
        }

        const mazeOffsetZ = startingRoomDepth + hallwayLength;
        const hallwayEndX = (startingRoomWidth - hallwayWidth) / 2;
        const hallwayCenterX = hallwayEndX + hallwayWidth / 2;
        
        const outerWalls = [];
        
        if (hallwayEndX > 0) {
            const leftWall = new THREE.Mesh(
                new THREE.BoxGeometry(hallwayEndX, 5, 0.3),
                wallMaterial
            );
            leftWall.position.set(hallwayEndX / 2, 2.5, mazeOffsetZ);
            scene.add(leftWall);
            walls.push(leftWall);
            outerWalls.push(leftWall);
        }
        
        const rightStartX = hallwayEndX + hallwayWidth;
        if (rightStartX < M * roomSize) {
            const rightWall = new THREE.Mesh(
                new THREE.BoxGeometry(M * roomSize - rightStartX, 5, 0.3),
                wallMaterial
            );
            rightWall.position.set(rightStartX + (M * roomSize - rightStartX) / 2, 2.5, mazeOffsetZ);
            scene.add(rightWall);
            walls.push(rightWall);
            outerWalls.push(rightWall);
        }
        
        const backWall = new THREE.Mesh(
            new THREE.BoxGeometry(M * roomSize, 5, 0.3),
            wallMaterial
        );
        backWall.position.set(M * roomSize / 2, 2.5, mazeOffsetZ + N * roomSize);
        scene.add(backWall);
        walls.push(backWall);
        outerWalls.push(backWall);
        
        const leftSideWall = new THREE.Mesh(
            new THREE.BoxGeometry(0.3, 5, N * roomSize),
            wallMaterial
        );
        leftSideWall.position.set(0, 2.5, mazeOffsetZ + N * roomSize / 2);
        scene.add(leftSideWall);
        walls.push(leftSideWall);
        outerWalls.push(leftSideWall);
        
        const rightSideWall = new THREE.Mesh(
            new THREE.BoxGeometry(0.3, 5, N * roomSize),
            wallMaterial
        );
        rightSideWall.position.set(M * roomSize, 2.5, mazeOffsetZ + N * roomSize / 2);
        scene.add(rightSideWall);
        walls.push(rightSideWall);
        outerWalls.push(rightSideWall);
        
        if (hallwayEndX > 0 || hallwayEndX + hallwayWidth < M * roomSize) {
            const leftTransWall = new THREE.Mesh(
                new THREE.BoxGeometry(0.3, 5, 2),
                wallMaterial
            );
            leftTransWall.position.set(hallwayEndX, 2.5, mazeOffsetZ + 1);
            scene.add(leftTransWall);
            walls.push(leftTransWall);
            
            const rightTransWall = new THREE.Mesh(
                new THREE.BoxGeometry(0.3, 5, 2),
                wallMaterial
            );
            rightTransWall.position.set(hallwayEndX + hallwayWidth, 2.5, mazeOffsetZ + 1);
            scene.add(rightTransWall);
            walls.push(rightTransWall);
        }

        for (let k = 0; k < N - 1; k++) {
            for (let j = 0; j < M; j++) {
                if (horizontalWalls[k][j]) {
                    const wall = new THREE.Mesh(
                        new THREE.BoxGeometry(roomSize, 5, 0.3),
                        wallMaterial
                    );
                    wall.position.set((j + 0.5) * roomSize, 2.5, mazeOffsetZ + (k + 1) * roomSize);
                    scene.add(wall);
                    walls.push(wall);
                }
            }
        }

        for (let i = 0; i < N; i++) {
            for (let l = 0; l < M - 1; l++) {
                if (verticalWalls[i][l]) {
                    const wall = new THREE.Mesh(
                        new THREE.BoxGeometry(0.3, 5, roomSize),
                        wallMaterial
                    );
                    wall.position.set((l + 1) * roomSize, 2.5, mazeOffsetZ + (i + 0.5) * roomSize);
                    scene.add(wall);
                    walls.push(wall);
                }
            }
        }

        createStartingRoom();
        createHallway();

        walls.forEach(wall => {
            wall.geometry.computeBoundingBox();
            wall.updateMatrixWorld(true);
            wall.worldBoundingBox = new THREE.Box3().copy(wall.geometry.boundingBox).applyMatrix4(wall.matrixWorld);
        });

        const mapWidth = Math.max(startingRoomWidth, M * roomSize);
        const mapDepth = startingRoomDepth + hallwayLength + N * roomSize;
        const floorSize = Math.max(mapWidth, mapDepth) + 20;

        const floorMaterial = new THREE.MeshStandardMaterial({
            map: floorTexture,
            normalMap: floorNormalMap,
            normalScale: new THREE.Vector2(0.5, 0.5),
            roughness: 0.9,
            metalness: 0.1,
            envMapIntensity: 1.0
        });

        const ceilingMaterial = new THREE.MeshStandardMaterial({
            map: ceilingTexture,
            color: 0xf5e6a3,
            roughness: 0.9,
            metalness: 0.0,
            envMapIntensity: 1.0
        });

        const floor = new THREE.Mesh(
            new THREE.PlaneGeometry(floorSize, floorSize),
            floorMaterial
        );
        floor.rotation.x = -Math.PI / 2;
        floor.position.set(floorSize / 2, 0, floorSize / 2);
        scene.add(floor);

        const ceiling = new THREE.Mesh(
            new THREE.PlaneGeometry(floorSize, floorSize),
            ceilingMaterial
        );
        ceiling.rotation.x = Math.PI / 2;
        ceiling.position.set(floorSize / 2, 5, floorSize / 2);
        scene.add(ceiling);

        // Add ambient light to the entire scene
        const ambientLight = new THREE.AmbientLight(0xffffcc, 0.3); // Soft yellowish ambient light
        scene.add(ambientLight);

        const lights = [];
        // Create light panels for all rooms but only add actual lights to a subset
        for (let i = 0; i < N; i++) {
            for (let j = 0; j < M; j++) {
                // Always create the light panel (visual element)
                const lightGeometry = new THREE.PlaneGeometry(1.5, 1.5);
                const lightMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    side: THREE.DoubleSide
                });

                const lightPanel = new THREE.Mesh(lightGeometry, lightMaterial);
                lightPanel.position.set((j + 0.5) * roomSize, 4.99, mazeOffsetZ + (i + 0.5) * roomSize);
                lightPanel.rotation.x = Math.PI / 2;
                scene.add(lightPanel);

                // Only add actual lights to a very sparse subset of rooms (every 4th room in both directions)
                if (i % 4 === 0 && j % 4 === 0) {
                    const light = new THREE.PointLight(0xffffee, 8, 40); // Adjusted intensity and increased range
                    light.position.set((j + 0.5) * roomSize, 4.5, mazeOffsetZ + (i + 0.5) * roomSize);
                    scene.add(light);
                    lights.push(light);
                }
            }
        }

        // Reduce lights in starting room - only add 1-2 lights instead of many
        const lightGeometry = new THREE.PlaneGeometry(1.5, 1.5);
        const lightMaterial = new THREE.MeshBasicMaterial({
            color: 0xffffff,
            side: THREE.DoubleSide
        });

        // Add light panels to all positions for visual consistency
        for (let x = 2; x < startingRoomWidth; x += 4) {
            for (let z = 2; z < startingRoomDepth; z += 4) {
                const lightPanel = new THREE.Mesh(lightGeometry, lightMaterial);
                lightPanel.position.set(x, 4.99, z);
                lightPanel.rotation.x = Math.PI / 2;
                scene.add(lightPanel);
            }
        }
        
        // But only add one actual light in the center of the starting room
        const startingRoomLight = new THREE.PointLight(0xffffee, 10, 35); // Adjusted intensity
        startingRoomLight.position.set(startingRoomWidth / 2, 4.5, startingRoomDepth / 2);
        scene.add(startingRoomLight);
        lights.push(startingRoomLight);

        const hallwayStartZ = startingRoomDepth;
        const hallwayStartX = (startingRoomWidth - hallwayWidth) / 2;
        
        // Add light panels along the hallway for visual consistency
        for (let z = hallwayStartZ + 4; z < hallwayStartZ + hallwayLength; z += 6) {
            const x = hallwayStartX + hallwayWidth / 2;
            
            const hallwayLightPanel = new THREE.Mesh(lightGeometry.clone(), lightMaterial.clone());
            hallwayLightPanel.position.set(x, 4.99, z);
            hallwayLightPanel.rotation.x = Math.PI / 2;
            scene.add(hallwayLightPanel);
        }
        
        // But only add a few actual lights in the hallway, spaced very far apart
        for (let z = hallwayStartZ + 25; z < hallwayStartZ + hallwayLength; z += 50) {
            const x = hallwayStartX + hallwayWidth / 2;
            
            const hallwayLight = new THREE.PointLight(0xffffee, 8, 45); // Adjusted intensity and increased range
            hallwayLight.position.set(x, 4.5, z);
            scene.add(hallwayLight);
            lights.push(hallwayLight);
        }

        let playerPosition = new THREE.Vector3(startingRoomWidth / 2, 2.0, startingRoomDepth / 2);
        const offset = new THREE.Vector3(0, 0, 0);
        let currentIntensity = 0.005;
        const restingIntensity = 0.005;
        const movingIntensity = 0.25;
        const runningIntensity = 0.4;
        const crouchingIntensity = 0.15;
        const transitionSpeed = 5;
        const playerRadius = 0.3;
        const remotePlayerRadius = 0.3;
        let remotePlayerYOffset = -0.01; // Small offset to ensure model appears grounded
        
        let walkCycle = 0;
        const walkFrequency = 7.0;
        const walkAmplitude = 0.09;
        const headBobAmplitude = 0.03;
        const walkLeanAmount = 0.07;
        const cameraRollAmount = 0.02;
        
        const walkSpeed = 5;
        const runSpeed = 8;
        const crouchSpeed = 2.5;
        
        let bobFactor = 0;
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });
        
        let frameCount = 0;
        let lastTime = 0;
        let fps = 0;
        
        let loadingProgressValue = 0;
        const loadingInterval = setInterval(() => {
            // Use fixed increments instead of random for consistent loading experience
            loadingProgressValue += 5;
            if (loadingProgressValue >= 100) {
                loadingProgressValue = 100;
                clearInterval(loadingInterval);
                
                loadingBar.style.width = '100%';
                loadingProgressElement.textContent = '100%';
                
                startButton.style.display = 'block';
            } else {
                loadingBar.style.width = `${loadingProgressValue}%`;
                loadingProgressElement.textContent = `${Math.floor(loadingProgressValue)}%`;
            }
        }, 200);

        function checkCollision(position, radius) {
            const sphere = new THREE.Sphere(position, radius);
            for (const wall of walls) {
                if (wall.worldBoundingBox && wall.worldBoundingBox.intersectsSphere(sphere)) {
                    return true;
                }
            }
            return false;
        }
        
        // Find a valid direction for the companion to move when stuck
        function findValidDirection(position, radius, preferredDirection, numAttempts = 8) {
            // First try the preferred direction
            if (!checkCollision(position.clone().add(preferredDirection.clone().multiplyScalar(radius * 2)), radius)) {
                return preferredDirection.clone();
            }
            
            // Try various angles around the circle
            const angleStep = (Math.PI * 2) / numAttempts;
            for (let i = 0; i < numAttempts; i++) {
                const angle = i * angleStep;
                const direction = new THREE.Vector3(
                    Math.cos(angle),
                    0,
                    Math.sin(angle)
                ).normalize();
                
                const testPosition = position.clone().add(direction.clone().multiplyScalar(radius * 2));
                if (!checkCollision(testPosition, radius)) {
                    return direction;
                }
            }
            
            // If all else fails, return a random direction
            const randomDir = new THREE.Vector3(
                Math.random() - 0.5,
                0,
                Math.random() - 0.5
            ).normalize();
            
            return randomDir;
        }

        function sendPlayerData() {
            if (isConnected && connection) {
                const isMoving = moveForward || moveBackward || moveLeft || moveRight;
                const isMovingBackward = moveBackward;
                
                // Create a quaternion from the camera container's rotation
                const quaternion = new THREE.Quaternion();
                cameraContainer.getWorldQuaternion(quaternion);
                
                connection.send({
                    type: 'position',
                    position: {
                        x: playerPosition.x,
                        y: playerPosition.y,
                        z: playerPosition.z
                    },
                    quaternion: {
                        x: quaternion.x,
                        y: quaternion.y,
                        z: quaternion.z,
                        w: quaternion.w
                    },
                    isMoving: isMoving,
                    isMovingBackward: isMovingBackward
                });
            }
        }

        function sendChatMessage(message) {
            if (isConnected && connection) {
                connection.send({
                    type: 'chat',
                    message: message
                });
                addChatMessage(message, 'self');
            }
        }

        function addChatMessage(message, type) {
            const messageElement = document.createElement('div');
            messageElement.classList.add('chat-message', type);
            
            if (type === 'self') {
                messageElement.textContent = `You: ${message}`;
            } else if (type === 'other') {
                messageElement.textContent = `Other: ${message}`;
            } else if (type === 'system') {
                messageElement.textContent = message;
            }
            
            chatMessages.appendChild(messageElement);
            chatMessages.scrollTop = chatMessages.scrollHeight;
            
            // Show chat container if it's hidden
            chatContainer.style.display = 'block';
            
            // Auto-hide system messages after 5 seconds
            if (type === 'system') {
                setTimeout(() => {
                    chatMessages.removeChild(messageElement);
                    
                    // Hide chat container if there are no messages
                    if (chatMessages.children.length === 0) {
                        chatContainer.style.display = 'none';
                    }
                }, 5000);
            }
        }

        // Initialize chat
        function initChat() {
            chatForm.addEventListener('submit', (e) => {
                e.preventDefault();
                
                const message = chatInput.value.trim();
                if (message) {
                    sendChatMessage(message);
                    chatInput.value = '';
                }
                
                // Exit chat mode
                isChatting = false;
                chatInput.blur();
                controls.lock();
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            
            frameCount++;
            const now = performance.now();
            if (now - lastTime >= 1000) {
                fps = Math.round((frameCount * 1000) / (now - lastTime));
                fpsCounter.textContent = `FPS: ${fps}`;
                frameCount = 0;
                lastTime = now;
            }
            
            if (!gameStarted) return;
            
            const delta = clock.getDelta();
            const currentTime = clock.getElapsedTime();
            
            // Send player data at regular intervals
            if (currentTime - lastDataSentTime >= DATA_SEND_INTERVAL) {
                sendPlayerData();
                lastDataSentTime = currentTime;
            }
            
            let speed = walkSpeed;
            if (isRunning && !isCrouching) {
                speed = runSpeed;
            } else if (isCrouching) {
                speed = crouchSpeed;
            }
            
            const distance = speed * delta;

            vhsPass.uniforms["time"].value += delta;

            const isMoving = moveForward || moveBackward || moveLeft || moveRight;
            
            if (isMoving && audioInitialized) {
                let stepInterval = 0.65;
                if (isRunning && !isCrouching) {
                    stepInterval = 0.45;
                } else if (isCrouching) {
                    stepInterval = 0.9;
                }
                
                if (currentTime - lastStepTime >= stepInterval) {
                    playFootstep();
                    lastStepTime = currentTime;
                }
            } else {
                lastStepTime = currentTime - 1.0;
            }
            
            let targetIntensity = restingIntensity;
            if (isMoving) {
                if (isRunning && !isCrouching) {
                    targetIntensity = runningIntensity;
                } else if (isCrouching) {
                    targetIntensity = crouchingIntensity;
                } else {
                    targetIntensity = movingIntensity;
                }
            }
            
            currentIntensity += (targetIntensity - currentIntensity) * transitionSpeed * delta;
            
            if (isMoving) {
                bobFactor = Math.min(bobFactor + delta * 2.5, 1);
            } else {
                bobFactor = Math.max(bobFactor - delta * 2.0, 0);
            }
            
            const cycleSpeed = walkFrequency * (isRunning && !isCrouching ? 1.5 : 1.0) * (isCrouching ? 0.7 : 1.0);
            walkCycle += cycleSpeed * delta;
            if (walkCycle > Math.PI * 2) {
                walkCycle -= Math.PI * 2;
            }
            
            offset.set(0, 0, 0);
            
            let amplitudeMultiplier = bobFactor;
            if (isRunning && !isCrouching) {
                amplitudeMultiplier *= 1.3;
            } else if (isCrouching) {
                amplitudeMultiplier *= 0.4;
            }
            
            offset.y = Math.sin(walkCycle) * walkAmplitude * amplitudeMultiplier;
            offset.x = Math.cos(walkCycle) * headBobAmplitude * amplitudeMultiplier;
            offset.z = Math.sin(walkCycle * 2) * walkLeanAmount * amplitudeMultiplier;
            
            const targetRoll = Math.sin(walkCycle * 1.5) * cameraRollAmount * amplitudeMultiplier;
            
            const randomScale = 0.003 * currentIntensity * (bobFactor * 0.8 + 0.2);
            offset.x += (Math.random() - 0.5) * randomScale * 1.5;
            offset.y += (Math.random() - 0.5) * randomScale * 1.5;
            offset.z += (Math.random() - 0.5) * randomScale * 1.5;
            
            if (bobFactor < 0.5) {
                const breathingStrength = (1 - bobFactor * 2) * 0.001;
                offset.y += Math.sin(clock.elapsedTime * 1.2) * breathingStrength;
            }

            const prevPlayerPosition = playerPosition.clone();

            if (moveForward)  controls.moveForward(distance);
            if (moveBackward) controls.moveForward(-distance);
            if (moveLeft)     controls.moveRight(-distance);
            if (moveRight)    controls.moveRight(distance);

            playerPosition.copy(cameraContainer.position);
            
            if (isCrouching) {
                playerPosition.y = 1.5;
            } else {
                playerPosition.y = 2.0;
            }
            cameraContainer.position.y = playerPosition.y;

            const playerSphere = new THREE.Sphere(playerPosition, playerRadius);
            let collision = false;
            
            for (const wall of walls) {
                if (wall.worldBoundingBox && wall.worldBoundingBox.intersectsSphere(playerSphere)) {
                    collision = true;
                    break;
                }
            }
            
            if (collision) {
                playerPosition.copy(prevPlayerPosition);
                cameraContainer.position.copy(playerPosition);
            }

            // Update remote player (replaces companion code)
            if (remotePlayerModel && remotePlayerMixer) {
                remotePlayerMixer.update(delta);
                
                // Calculate distance moved since last frame
                const distanceMoved = remotePlayerPosition.distanceTo(remotePlayerLastPosition);
                remotePlayerLastPosition.copy(remotePlayerPosition);
                
                // Update position - add Y offset to the model's position
                remotePlayerModel.position.set(
                    remotePlayerPosition.x,
                    remotePlayerYOffset, // Use Y offset for grounding
                    remotePlayerPosition.z
                );
                
                // Apply quaternion rotation directly
                // Extract only the Y-axis rotation (yaw) from the quaternion
                // This prevents the model from tilting up/down when the player looks up/down
                const euler = new THREE.Euler().setFromQuaternion(remotePlayerQuaternion, 'YXZ');
                const yawOnlyQuaternion = new THREE.Quaternion().setFromEuler(
                    new THREE.Euler(0, euler.y, 0, 'YXZ')
                );
                remotePlayerModel.quaternion.copy(yawOnlyQuaternion);
                
                // Log position and rotation occasionally for debugging
                if (Math.random() < 0.01) { // Log approximately once every 100 frames
                    console.log("Remote player update:", {
                        position: remotePlayerModel.position.clone(),
                        quaternion: remotePlayerQuaternion.clone(),
                        moving: remotePlayerMoving
                    });
                }
                
                // Handle remote player backflip animation
                if (isRemotePlayerBackflipping) {
                    const backflipElapsed = currentTime - backflipStartTime;
                    const backflipProgress = backflipElapsed / backflipDuration;
                    
                    // End backflip when animation completes
                    if (backflipElapsed >= backflipDuration) {
                        isRemotePlayerBackflipping = false;
                        
                        // Transition back to idle animation
                        if (remotePlayerBackflipAction) remotePlayerBackflipAction.weight = 0;
                        if (remotePlayerIdleAction) {
                            remotePlayerIdleAction.weight = 1;
                            remotePlayerIdleAction.play();
                        }
                    }
                }
                // Only update walking/idle animations if not backflipping
                else if (remotePlayerWalkAction && remotePlayerIdleAction && !isRemotePlayerBackflipping) {
                    if (remotePlayerMoving) {
                        // Set animation direction based on movement
                        if (remotePlayerMovingBackward) {
                            // Play animation in reverse when moving backward
                            remotePlayerWalkAction.timeScale = -1;
                        } else {
                            // Play animation forward when moving forward
                            remotePlayerWalkAction.timeScale = 1;
                        }
                        
                        // Crossfade from idle to walking
                        if (remotePlayerWalkAction.weight < 1.0) {
                            remotePlayerIdleAction.weight = 1 - remotePlayerWalkAction.weight;
                            remotePlayerWalkAction.weight += delta / animationCrossfadeTime;
                            if (remotePlayerWalkAction.weight > 1.0) {
                                remotePlayerWalkAction.weight = 1.0;
                                remotePlayerIdleAction.weight = 0.0;
                            }
                        }
                        
                        // Ensure walking animation is playing
                        if (!remotePlayerWalkAction.isRunning()) {
                            remotePlayerWalkAction.play();
                        }
                        
                        // Play footstep sounds for remote player
                        if (audioInitialized) {
                            // Calculate step interval based on distance
                            let remoteStepInterval = 0.5;
                            
                            // Adjust step interval based on distance to player
                            const distanceToPlayer = playerPosition.distanceTo(remotePlayerPosition);
                            if (distanceToPlayer > 3) {
                                remoteStepInterval = 0.4; // Faster steps when far away
                            } else if (distanceToPlayer < 1.5) {
                                remoteStepInterval = 0.6; // Slower steps when close
                            }
                            
                            // Add slight randomness to step timing using seeded random
                            remoteStepInterval *= 0.9 + remoteFootstepRandom.random() * 0.2;
                            
                            if (currentTime - lastRemoteStepTime >= remoteStepInterval) {
                                playRemotePlayerFootstep();
                                lastRemoteStepTime = currentTime;
                            }
                    }
                } else {
                        // Crossfade from walking to idle
                        if (remotePlayerIdleAction.weight < 1.0) {
                            remotePlayerWalkAction.weight = 1 - remotePlayerIdleAction.weight;
                            remotePlayerIdleAction.weight += delta / animationCrossfadeTime;
                            if (remotePlayerIdleAction.weight > 1.0) {
                                remotePlayerIdleAction.weight = 1.0;
                                remotePlayerWalkAction.weight = 0.0;
                            }
                        }
                        
                        // Ensure idle animation is playing
                        if (!remotePlayerIdleAction.isRunning()) {
                            remotePlayerIdleAction.play();
                        }
                    }
                }
                
                // Check for collision between players
                const playerToRemoteDistance = playerPosition.distanceTo(remotePlayerPosition);
                if (playerToRemoteDistance < playerRadius + remotePlayerRadius) {
                    // Push players apart slightly to prevent clipping
                    const pushDirection = new THREE.Vector3()
                        .subVectors(playerPosition, remotePlayerPosition)
                        .normalize();
                    
                    const pushAmount = (playerRadius + remotePlayerRadius - playerToRemoteDistance) * 0.5;
                    playerPosition.add(pushDirection.clone().multiplyScalar(pushAmount));
                    cameraContainer.position.copy(playerPosition);
                }
            }

            camera.position.copy(offset);
            camera.rotation.z = camera.rotation.z * 0.85 + targetRoll * 0.15;

            // Handle local player backflip
            if (isLocalPlayerBackflipping) {
                const backflipElapsed = currentTime - backflipStartTime;
                const backflipProgress = backflipElapsed / backflipDuration;
                
                // Rotate camera during backflip
                if (backflipProgress <= 1.0) {
                    // Rotate camera 360 degrees around X axis
                    const rotationAngle = Math.PI * 2 * backflipProgress;
                    camera.rotation.x = rotationAngle;
                }
                
                // End backflip when animation completes
                if (backflipElapsed >= backflipDuration) {
                    isLocalPlayerBackflipping = false;
                    
                    // Reset camera rotation
                    camera.rotation.x = 0;
                }
            }

            updateAudio();

            composer.render();
        }

        function getDistanceToNearestLight(position) {
            let minDistance = Infinity;
            for (const light of lights) {
                const distance = position.distanceTo(light.position);
                if (distance < minDistance) {
                    minDistance = distance;
                }
            }
            return minDistance;
        }
        
        function updateAudio() {
            if (!fluorescentBuzz.paused) {
                const distanceToLight = getDistanceToNearestLight(playerPosition);
                const maxDistance = 15;
                const minDistance = 2;
                
                let distanceVolume = 1.0;
                if (distanceToLight > minDistance) {
                    distanceVolume = Math.max(0, 1 - ((distanceToLight - minDistance) / (maxDistance - minDistance)));
                }
                
                fluorescentBuzz.volume = masterVolume * distanceVolume;
                
                // Use seeded random for audio fluctuations
                if (audioRandom.random() < 0.05) {
                    const fluctuation = 0.95 + audioRandom.random() * 0.1;
                    fluorescentBuzz.volume *= fluctuation;
                }
            } else if (gameStarted && !fluorescentBuzz.muted) {
                fluorescentBuzz.play().catch(e => console.log("Couldn't restart audio in update:", e));
            }
            
            // Update player footstep volumes
            stepSounds.forEach(sound => {
                sound.volume = masterVolume * footstepVolume;
            });
            
            // Update remote player footstep volumes
            remotePlayerStepSounds.forEach(sound => {
                // Adjust volume based on distance to player
                const distanceToPlayer = playerPosition.distanceTo(remotePlayerPosition);
                const maxDistance = 15;
                const minDistance = 1;
                
                let distanceFactor = 1.0;
                if (distanceToPlayer > minDistance) {
                    distanceFactor = Math.max(0.2, 1 - ((distanceToPlayer - minDistance) / (maxDistance - minDistance)));
                }
                
                sound.volume = masterVolume * footstepVolume * 0.4 * distanceFactor;
            });
        }

        // Multiplayer setup
        function initPeerJS() {
            peer = new Peer();
            
            peer.on('open', (id) => {
                console.log('My peer ID is: ' + id);
                myPeerIdElement.textContent = id;
                multiplayerUI.style.display = 'block';
            });
            
            peer.on('connection', (conn) => {
                handleConnection(conn);
                isHost = true;
            });
            
            peer.on('error', (err) => {
                console.error('PeerJS error:', err);
                connectionStatus.textContent = 'Connection error: ' + err;
            });
            
            connectButton.addEventListener('click', () => {
                const remotePeerId = remotePeerIdInput.value.trim();
                if (remotePeerId) {
                    connectionStatus.textContent = 'Connecting...';
                    const conn = peer.connect(remotePeerId);
                    handleConnection(conn);
                    isHost = false;
                }
            });
        }
        
        function handleConnection(conn) {
            connection = conn;
            
            connection.on('open', () => {
                console.log('Connected to peer:', connection.peer);
                connectionStatus.textContent = 'Connected to: ' + connection.peer;
                isConnected = true;
                
                // Hide the connection form once connected
                document.getElementById('connect-form').style.display = 'none';
                
                // Show system message
                addChatMessage('Connected to another player', 'system');
                addChatMessage('The maze layout is identical for all players', 'system');
                
                // Load the remote player model
                loadRemotePlayerModel();
            });
            
            connection.on('data', (data) => {
                handlePeerData(data);
            });
            
            connection.on('close', () => {
                console.log('Connection closed');
                connectionStatus.textContent = 'Connection closed';
                isConnected = false;
                
                // Show system message
                addChatMessage('Disconnected from player', 'system');
                
                // Show the connection form again
                document.getElementById('connect-form').style.display = 'flex';
                
                // Remove the remote player model
                if (remotePlayerModel) {
                    scene.remove(remotePlayerModel);
                    remotePlayerModel = null;
                }
            });
            
            connection.on('error', (err) => {
                console.error('Connection error:', err);
                connectionStatus.textContent = 'Connection error: ' + err;
                
                // Show system message
                addChatMessage('Connection error: ' + err, 'system');
            });
        }
        
        function handlePeerData(data) {
            if (data.type === 'position') {
                // Update remote player position
                remotePlayerPosition.set(
                    data.position.x,
                    data.position.y,
                    data.position.z
                );
                
                // Store the quaternion data for rotation
                remotePlayerQuaternion.set(
                    data.quaternion.x,
                    data.quaternion.y,
                    data.quaternion.z,
                    data.quaternion.w
                );
                
                remotePlayerMoving = data.isMoving;
                remotePlayerMovingBackward = data.isMovingBackward; // Store backward movement state
            } else if (data.type === 'chat') {
                addChatMessage(data.message, 'other');
            } else if (data.type === 'backflip') {
                // Trigger backflip animation for remote player
                if (remotePlayerBackflipAction && !isRemotePlayerBackflipping) {
                    isRemotePlayerBackflipping = true;
                    backflipStartTime = clock.getElapsedTime();
                    
                    // Reset weights of other animations
                    if (remotePlayerIdleAction) remotePlayerIdleAction.weight = 0;
                    if (remotePlayerWalkAction) remotePlayerWalkAction.weight = 0;
                    
                    // Set backflip animation weight to 1
                    remotePlayerBackflipAction.reset();
                    remotePlayerBackflipAction.weight = 1;
                    remotePlayerBackflipAction.play();
                    
                    // Add chat message
                    addChatMessage('Other player is doing a backflip!', 'system');
                }
            }
        }
        
        function loadRemotePlayerModel() {
            // Set up DRACO loader for decompression
            const dracoLoader = new DRACOLoader();
            dracoLoader.setDecoderPath('https://www.gstatic.com/draco/versioned/decoders/1.5.6/');
            
            // Set up GLTF loader with DRACO loader
            const loader = new GLTFLoader();
            loader.setDRACOLoader(dracoLoader);
            
            loader.load(
                'character.glb',
                (gltf) => {
                    console.log("GLTF model loaded successfully:", gltf);
                    createRemotePlayerFromGLTF(gltf);
                },
                (xhr) => {
                    console.log((xhr.loaded / xhr.total * 100) + '% loaded remote player model');
                },
                (error) => {
                    console.error('Error loading GLTF model:', error);
                    addChatMessage('Error loading character model, using fallback', 'system');
                    createFallbackRemotePlayer();
                }
            );
        }
        
        function createRemotePlayerFromGLTF(gltf) {
            // Create a container for the model to handle rotation correctly
            const modelContainer = new THREE.Group();
            
            // Get the model from the GLTF scene
            const model = gltf.scene;
            
            // Add the model to the container with a 180-degree rotation
            // This ensures the model faces forward relative to the camera direction
            model.rotation.y = Math.PI;
            modelContainer.add(model);
            
            // Position the container at the initial position
            remotePlayerPosition.set(startingRoomWidth / 2 - 1, 0, startingRoomDepth / 2 - 1);
            remotePlayerLastPosition.copy(remotePlayerPosition);
            modelContainer.position.copy(remotePlayerPosition);
            
            // Add the container to the scene
            scene.add(modelContainer);
            
            // Use the container as our remote player model
            remotePlayerModel = modelContainer;
            
            // Log model dimensions to help with debugging
            const box = new THREE.Box3().setFromObject(model);
            const size = box.getSize(new THREE.Vector3());
            console.log("Model dimensions:", size);
            
            // Adjust scale to match desired height (around 1.7-1.8 units)
            const targetHeight = 3.0;
            if (size.y > 0) {
                const scale = targetHeight / size.y;
                model.scale.set(scale, scale, scale);
                console.log("Adjusted model scale to:", scale);
                
                // Recalculate bounding box after scaling
                const newBox = new THREE.Box3().setFromObject(model);
                const newSize = newBox.getSize(new THREE.Vector3());
                console.log("New model dimensions:", newSize);
                
                // Adjust Y offset based on model height
                remotePlayerYOffset = 0; // Reset to zero as we've scaled the model appropriately
            }
            
            // Setup animation mixer
            remotePlayerMixer = new THREE.AnimationMixer(model);
            
            // Find the idle and walking animations
            let idleAnimation = null;
            let walkingAnimation = null;
            let backflipAnimation = null;

            if (gltf.animations && gltf.animations.length > 0) {
                console.log("Available animations:", gltf.animations);
                
                // Find animations by name
                gltf.animations.forEach(clip => {
                    if (clip.name.toLowerCase().includes('idle')) {
                        idleAnimation = clip;
                    } else if (clip.name.toLowerCase().includes('walk')) {
                        walkingAnimation = clip;
                    } else if (clip.name.toLowerCase().includes('backflip')) {
                        backflipAnimation = clip;
                    }
                });
                
                // If we found the animations, set them up
                if (idleAnimation) {
                    console.log("Found idle animation:", idleAnimation);
                    remotePlayerIdleAction = remotePlayerMixer.clipAction(idleAnimation);
                    remotePlayerIdleAction.setLoop(THREE.LoopRepeat);
                    remotePlayerIdleAction.play();
                    remotePlayerIdleAction.weight = 1.0; // Start with idle animation fully weighted
                } else {
                    console.warn("No idle animation found");
                }
                
                if (walkingAnimation) {
                    console.log("Found walking animation:", walkingAnimation);
                    remotePlayerWalkAction = remotePlayerMixer.clipAction(walkingAnimation);
                    remotePlayerWalkAction.setLoop(THREE.LoopRepeat);
                    remotePlayerWalkAction.timeScale = 1; // Set initial timeScale to forward
                    remotePlayerWalkAction.play();
                    remotePlayerWalkAction.weight = 0.0; // Start with walking animation at zero weight
                } else {
                    console.warn("No walking animation found");
                }
                
                if (backflipAnimation) {
                    console.log("Found backflip animation:", backflipAnimation);
                    remotePlayerBackflipAction = remotePlayerMixer.clipAction(backflipAnimation);
                    remotePlayerBackflipAction.setLoop(THREE.LoopOnce); // Only play once
                    remotePlayerBackflipAction.clampWhenFinished = true; // Hold the last frame when finished
                    remotePlayerBackflipAction.timeScale = 1;
                    remotePlayerBackflipAction.weight = 0.0; // Start with backflip animation at zero weight
                    
                    // Get the duration of the backflip animation
                    backflipDuration = backflipAnimation.duration;
                    console.log("Backflip duration:", backflipDuration);
                } else {
                    console.warn("No backflip animation found");
                }
            } else {
                console.warn("No animations found in the model");
            }
            
            // Compute bounding box and apply materials
            model.traverse((child) => {
                if (child.isMesh) {
                    console.log("Found mesh in model:", child.name);
                    child.geometry.computeBoundingBox();
                    
                    // Apply materials if needed
                    if (child.material) {
                        // You can customize the remote player's appearance here if desired
                        // For example, to make them a different color:
                        // if (Array.isArray(child.material)) {
                        //     child.material.forEach(mat => {
                        //         mat.color.setHex(0x66a8e5); // Blue tint
                        //     });
                        // } else {
                        //     child.material.color.setHex(0x66a8e5); // Blue tint
                        // }
                        child.material.needsUpdate = true;
                    }
                }
            });
            
            // Create a direction helper arrow
            const arrowDir = new THREE.Vector3(0, 0, -1);
            const arrowOrigin = new THREE.Vector3(0, 1.5, 0);
            const arrowLength = 2;
            const arrowColor = 0xff0000;
            const headLength = 0.5; // Length of the arrow head
            const headWidth = 0.3; // Width of the arrow head
            directionHelper = new THREE.ArrowHelper(arrowDir, arrowOrigin, arrowLength, arrowColor, headLength, headWidth);
            remotePlayerModel.add(directionHelper);
            
            // Add debug objects to help visualize the model position
            // Red sphere at the center
            const centerSphere = new THREE.Mesh(
                new THREE.SphereGeometry(0.1, 16, 16),
                new THREE.MeshBasicMaterial({ color: 0xff0000 })
            );
            centerSphere.position.set(0, 0, 0);
            remotePlayerModel.add(centerSphere);
            
            // Green sphere at head height
            const headSphere = new THREE.Mesh(
                new THREE.SphereGeometry(0.1, 16, 16),
                new THREE.MeshBasicMaterial({ color: 0x00ff00 })
            );
            headSphere.position.set(0, 1.5, 0);
            remotePlayerModel.add(headSphere);
            
            // Blue sphere in front
            const frontSphere = new THREE.Mesh(
                new THREE.SphereGeometry(0.1, 16, 16),
                new THREE.MeshBasicMaterial({ color: 0x0000ff })
            );
            frontSphere.position.set(0, 1, -1);
            remotePlayerModel.add(frontSphere);
            
            // Show system message
            addChatMessage('Remote player model loaded', 'system');
            addChatMessage('Press V to toggle direction helper', 'system');
        }
        
        function createFallbackRemotePlayer() {
            // Create a simple humanoid shape as fallback
            const modelContainer = new THREE.Group();
            
            // Create a body
            const bodyGeometry = new THREE.CapsuleGeometry(0.3, 1.0, 4, 8);
            const bodyMaterial = new THREE.MeshBasicMaterial({ color: 0x66a8e5 });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.set(0, 0.8, 0);
            modelContainer.add(body);
            
            // Create a head
            const headGeometry = new THREE.SphereGeometry(0.25, 16, 16);
            const headMaterial = new THREE.MeshBasicMaterial({ color: 0x66a8e5 });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.set(0, 1.7, 0);
            modelContainer.add(head);
            
            // Position the container at the initial position
            remotePlayerPosition.set(startingRoomWidth / 2 - 1, 0, startingRoomDepth / 2 - 1);
            remotePlayerLastPosition.copy(remotePlayerPosition);
            modelContainer.position.copy(remotePlayerPosition);
            
            // Add the container to the scene
            scene.add(modelContainer);
            
            // Use the container as our remote player model
            remotePlayerModel = modelContainer;
            
            // Create a direction helper arrow
            const arrowDir = new THREE.Vector3(0, 0, -1);
            const arrowOrigin = new THREE.Vector3(0, 1.5, 0);
            const arrowLength = 2;
            const arrowColor = 0xff0000;
            const headLength = 0.5;
            const headWidth = 0.3;
            directionHelper = new THREE.ArrowHelper(arrowDir, arrowOrigin, arrowLength, arrowColor, headLength, headWidth);
            remotePlayerModel.add(directionHelper);
            
            // Add debug spheres
            const centerSphere = new THREE.Mesh(
                new THREE.SphereGeometry(0.1, 16, 16),
                new THREE.MeshBasicMaterial({ color: 0xff0000 })
            );
            centerSphere.position.set(0, 0, 0);
            remotePlayerModel.add(centerSphere);
            
            const frontSphere = new THREE.Mesh(
                new THREE.SphereGeometry(0.1, 16, 16),
                new THREE.MeshBasicMaterial({ color: 0x0000ff })
            );
            frontSphere.position.set(0, 1, -1);
            remotePlayerModel.add(frontSphere);
            
            // Show system message
            addChatMessage('Using fallback player model', 'system');
            addChatMessage('Press V to toggle direction helper', 'system');
        }

        // Initialize game
        function initGame() {
            gameStarted = true;
            loadingScreen.style.opacity = '0';
            setTimeout(() => {
                loadingScreen.style.display = 'none';
                controls.lock();
                initAudio();
                initPeerJS(); // Initialize PeerJS when the game starts
                initChat(); // Initialize chat system
            }, 1000);
            
            clock.start();
            animate();
        }

        // Start button event listener
        startButton.addEventListener('click', initGame);

        // Handle local player backflip
        if (isLocalPlayerBackflipping) {
            const backflipElapsed = currentTime - backflipStartTime;
            const backflipProgress = backflipElapsed / backflipDuration;
            
            // Rotate camera during backflip
            if (backflipProgress <= 1.0) {
                // Rotate camera 360 degrees around X axis
                const rotationAngle = Math.PI * 2 * backflipProgress;
                camera.rotation.x = rotationAngle;
            }
            
            // End backflip when animation completes
            if (backflipElapsed >= backflipDuration) {
                isLocalPlayerBackflipping = false;
                
                // Reset camera rotation
                camera.rotation.x = 0;
            }
        }
    </script>
</body>
</html>